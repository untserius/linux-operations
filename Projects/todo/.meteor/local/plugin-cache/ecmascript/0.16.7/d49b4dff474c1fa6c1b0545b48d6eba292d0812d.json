{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/serius/Desktop/Practicals/Projects/todo/packages/minimongo/cursor.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/minimongo/cursor.js","filename":"/home/serius/Desktop/Practicals/Projects/todo/packages/minimongo/cursor.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/serius/Desktop/Practicals/Projects/todo","root":"/home/serius/Desktop/Practicals/Projects/todo","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/home/serius/Desktop/Practicals/Projects/todo/packages/minimongo/cursor.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/minimongo/cursor.js"}},"code":"module.export({\n  default: () => Cursor\n});\nlet LocalCollection;\nmodule.link(\"./local_collection.js\", {\n  default(v) {\n    LocalCollection = v;\n  }\n}, 0);\nlet hasOwn;\nmodule.link(\"./common.js\", {\n  hasOwn(v) {\n    hasOwn = v;\n  }\n}, 1);\nlet ASYNC_CURSOR_METHODS, getAsyncMethodName;\nmodule.link(\"./constants\", {\n  ASYNC_CURSOR_METHODS(v) {\n    ASYNC_CURSOR_METHODS = v;\n  },\n  getAsyncMethodName(v) {\n    getAsyncMethodName = v;\n  }\n}, 2);\nclass Cursor {\n  // don't call this ctor directly.  use LocalCollection.find().\n  constructor(collection, selector) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.collection = collection;\n    this.sorter = null;\n    this.matcher = new Minimongo.Matcher(selector);\n    if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n      // stash for fast _id and { _id }\n      this._selectorId = hasOwn.call(selector, '_id') ? selector._id : selector;\n    } else {\n      this._selectorId = undefined;\n      if (this.matcher.hasGeoQuery() || options.sort) {\n        this.sorter = new Minimongo.Sorter(options.sort || []);\n      }\n    }\n    this.skip = options.skip || 0;\n    this.limit = options.limit;\n    this.fields = options.projection || options.fields;\n    this._projectionFn = LocalCollection._compileProjection(this.fields || {});\n    this._transform = LocalCollection.wrapTransform(options.transform);\n\n    // by default, queries register w/ Tracker when it is available.\n    if (typeof Tracker !== 'undefined') {\n      this.reactive = options.reactive === undefined ? true : options.reactive;\n    }\n  }\n\n  /**\n   * @deprecated in 2.9\n   * @summary Returns the number of documents that match a query. This method is\n   *          [deprecated since MongoDB 4.0](https://www.mongodb.com/docs/v4.4/reference/command/count/);\n   *          see `Collection.countDocuments` and\n   *          `Collection.estimatedDocumentCount` for a replacement.\n   * @memberOf Mongo.Cursor\n   * @method  count\n   * @instance\n   * @locus Anywhere\n   * @returns {Number}\n   */\n  count() {\n    if (this.reactive) {\n      // allow the observe to be unordered\n      this._depend({\n        added: true,\n        removed: true\n      }, true);\n    }\n    return this._getRawObjects({\n      ordered: true\n    }).length;\n  }\n\n  /**\n   * @summary Return all matching documents as an Array.\n   * @memberOf Mongo.Cursor\n   * @method  fetch\n   * @instance\n   * @locus Anywhere\n   * @returns {Object[]}\n   */\n  fetch() {\n    const result = [];\n    this.forEach(doc => {\n      result.push(doc);\n    });\n    return result;\n  }\n  [Symbol.iterator]() {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true\n      });\n    }\n    let index = 0;\n    const objects = this._getRawObjects({\n      ordered: true\n    });\n    return {\n      next: () => {\n        if (index < objects.length) {\n          // This doubles as a clone operation.\n          let element = this._projectionFn(objects[index++]);\n          if (this._transform) element = this._transform(element);\n          return {\n            value: element\n          };\n        }\n        return {\n          done: true\n        };\n      }\n    };\n  }\n  [Symbol.asyncIterator]() {\n    const syncResult = this[Symbol.iterator]();\n    return {\n      next() {\n        return Promise.asyncApply(() => {\n          return Promise.resolve(syncResult.next());\n        });\n      }\n    };\n  }\n\n  /**\n   * @callback IterationCallback\n   * @param {Object} doc\n   * @param {Number} index\n   */\n  /**\n   * @summary Call `callback` once for each matching document, sequentially and\n   *          synchronously.\n   * @locus Anywhere\n   * @method  forEach\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  forEach(callback, thisArg) {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true\n      });\n    }\n    this._getRawObjects({\n      ordered: true\n    }).forEach((element, i) => {\n      // This doubles as a clone operation.\n      element = this._projectionFn(element);\n      if (this._transform) {\n        element = this._transform(element);\n      }\n      callback.call(thisArg, element, i, this);\n    });\n  }\n  getTransform() {\n    return this._transform;\n  }\n\n  /**\n   * @summary Map callback over all matching documents.  Returns an Array.\n   * @locus Anywhere\n   * @method map\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  map(callback, thisArg) {\n    const result = [];\n    this.forEach((doc, i) => {\n      result.push(callback.call(thisArg, doc, i, this));\n    });\n    return result;\n  }\n\n  // options to contain:\n  //  * callbacks for observe():\n  //    - addedAt (document, atIndex)\n  //    - added (document)\n  //    - changedAt (newDocument, oldDocument, atIndex)\n  //    - changed (newDocument, oldDocument)\n  //    - removedAt (document, atIndex)\n  //    - removed (document)\n  //    - movedTo (document, oldIndex, newIndex)\n  //\n  // attributes available on returned query handle:\n  //  * stop(): end updates\n  //  * collection: the collection this query is querying\n  //\n  // iff x is a returned query handle, (x instanceof\n  // LocalCollection.ObserveHandle) is true\n  //\n  // initial results delivered through added callback\n  // XXX maybe callbacks should take a list of objects, to expose transactions?\n  // XXX maybe support field limiting (to limit what you're notified on)\n\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observe(options) {\n    return LocalCollection._observeFromObserveChanges(this, options);\n  }\n\n  /**\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\n   *          the differences between the old and new documents are passed to\n   *          the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observeChanges(options) {\n    const ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\n\n    // there are several places that assume you aren't combining skip/limit with\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n    // comment in _modifyAndNotify\n    // XXX allow skip/limit with unordered observe\n    if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\n      throw new Error(\"Must use an ordered observe with skip or limit (i.e. 'addedBefore' \" + \"for observeChanges or 'addedAt' for observe, instead of 'added').\");\n    }\n    if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\n      throw Error('You may not observe a cursor with {fields: {_id: 0}}');\n    }\n    const distances = this.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap();\n    const query = {\n      cursor: this,\n      dirty: false,\n      distances,\n      matcher: this.matcher,\n      // not fast pathed\n      ordered,\n      projectionFn: this._projectionFn,\n      resultsSnapshot: null,\n      sorter: ordered && this.sorter\n    };\n    let qid;\n\n    // Non-reactive queries call added[Before] and then never call anything\n    // else.\n    if (this.reactive) {\n      qid = this.collection.next_qid++;\n      this.collection.queries[qid] = query;\n    }\n    query.results = this._getRawObjects({\n      ordered,\n      distances: query.distances\n    });\n    if (this.collection.paused) {\n      query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap();\n    }\n\n    // wrap callbacks we were passed. callbacks only fire when not paused and\n    // are never undefined\n    // Filters out blacklisted fields according to cursor's projection.\n    // XXX wrong place for this?\n\n    // furthermore, callbacks enqueue until the operation we're working on is\n    // done.\n    const wrapCallback = fn => {\n      if (!fn) {\n        return () => {};\n      }\n      const self = this;\n      return function /* args*/\n      () {\n        if (self.collection.paused) {\n          return;\n        }\n        const args = arguments;\n        self.collection._observeQueue.queueTask(() => {\n          fn.apply(this, args);\n        });\n      };\n    };\n    query.added = wrapCallback(options.added);\n    query.changed = wrapCallback(options.changed);\n    query.removed = wrapCallback(options.removed);\n    if (ordered) {\n      query.addedBefore = wrapCallback(options.addedBefore);\n      query.movedBefore = wrapCallback(options.movedBefore);\n    }\n    if (!options._suppress_initial && !this.collection.paused) {\n      query.results.forEach(doc => {\n        const fields = EJSON.clone(doc);\n        delete fields._id;\n        if (ordered) {\n          query.addedBefore(doc._id, this._projectionFn(fields), null);\n        }\n        query.added(doc._id, this._projectionFn(fields));\n      });\n    }\n    const handle = Object.assign(new LocalCollection.ObserveHandle(), {\n      collection: this.collection,\n      stop: () => {\n        if (this.reactive) {\n          delete this.collection.queries[qid];\n        }\n      }\n    });\n    if (this.reactive && Tracker.active) {\n      // XXX in many cases, the same observe will be recreated when\n      // the current autorun is rerun.  we could save work by\n      // letting it linger across rerun and potentially get\n      // repurposed if the same observe is performed, using logic\n      // similar to that of Meteor.subscribe.\n      Tracker.onInvalidate(() => {\n        handle.stop();\n      });\n    }\n\n    // run the observe callbacks resulting from the initial contents\n    // before we leave the observe.\n    this.collection._observeQueue.drain();\n    return handle;\n  }\n\n  // XXX Maybe we need a version of observe that just calls a callback if\n  // anything changed.\n  _depend(changers, _allow_unordered) {\n    if (Tracker.active) {\n      const dependency = new Tracker.Dependency();\n      const notify = dependency.changed.bind(dependency);\n      dependency.depend();\n      const options = {\n        _allow_unordered,\n        _suppress_initial: true\n      };\n      ['added', 'addedBefore', 'changed', 'movedBefore', 'removed'].forEach(fn => {\n        if (changers[fn]) {\n          options[fn] = notify;\n        }\n      });\n\n      // observeChanges will stop() when this computation is invalidated\n      this.observeChanges(options);\n    }\n  }\n  _getCollectionName() {\n    return this.collection.name;\n  }\n\n  // Returns a collection of matching objects, but doesn't deep copy them.\n  //\n  // If ordered is set, returns a sorted array, respecting sorter, skip, and\n  // limit properties of the query provided that options.applySkipLimit is\n  // not set to false (#1201). If sorter is falsey, no sort -- you get the\n  // natural order.\n  //\n  // If ordered is not set, returns an object mapping from ID to doc (sorter,\n  // skip and limit should not be set).\n  //\n  // If ordered is set and this cursor is a $near geoquery, then this function\n  // will use an _IdMap to track each distance from the $near argument point in\n  // order to use it as a sort key. If an _IdMap is passed in the 'distances'\n  // argument, this function will clear it and use it for this purpose\n  // (otherwise it will just create its own _IdMap). The observeChanges\n  // implementation uses this to remember the distances after this function\n  // returns.\n  _getRawObjects() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // By default this method will respect skip and limit because .fetch(),\n    // .forEach() etc... expect this behaviour. It can be forced to ignore\n    // skip and limit by setting applySkipLimit to false (.count() does this,\n    // for example)\n    const applySkipLimit = options.applySkipLimit !== false;\n\n    // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n    // compatible\n    const results = options.ordered ? [] : new LocalCollection._IdMap();\n\n    // fast path for single ID value\n    if (this._selectorId !== undefined) {\n      // If you have non-zero skip and ask for a single id, you get nothing.\n      // This is so it matches the behavior of the '{_id: foo}' path.\n      if (applySkipLimit && this.skip) {\n        return results;\n      }\n      const selectedDoc = this.collection._docs.get(this._selectorId);\n      if (selectedDoc) {\n        if (options.ordered) {\n          results.push(selectedDoc);\n        } else {\n          results.set(this._selectorId, selectedDoc);\n        }\n      }\n      return results;\n    }\n\n    // slow path for arbitrary selector, sort, skip, limit\n\n    // in the observeChanges case, distances is actually part of the \"query\"\n    // (ie, live results set) object.  in other cases, distances is only used\n    // inside this function.\n    let distances;\n    if (this.matcher.hasGeoQuery() && options.ordered) {\n      if (options.distances) {\n        distances = options.distances;\n        distances.clear();\n      } else {\n        distances = new LocalCollection._IdMap();\n      }\n    }\n    this.collection._docs.forEach((doc, id) => {\n      const matchResult = this.matcher.documentMatches(doc);\n      if (matchResult.result) {\n        if (options.ordered) {\n          results.push(doc);\n          if (distances && matchResult.distance !== undefined) {\n            distances.set(id, matchResult.distance);\n          }\n        } else {\n          results.set(id, doc);\n        }\n      }\n\n      // Override to ensure all docs are matched if ignoring skip & limit\n      if (!applySkipLimit) {\n        return true;\n      }\n\n      // Fast path for limited unsorted queries.\n      // XXX 'length' check here seems wrong for ordered\n      return !this.limit || this.skip || this.sorter || results.length !== this.limit;\n    });\n    if (!options.ordered) {\n      return results;\n    }\n    if (this.sorter) {\n      results.sort(this.sorter.getComparator({\n        distances\n      }));\n    }\n\n    // Return the full set of results if there is no skip or limit or if we're\n    // ignoring them\n    if (!applySkipLimit || !this.limit && !this.skip) {\n      return results;\n    }\n    return results.slice(this.skip, this.limit ? this.limit + this.skip : results.length);\n  }\n  _publishCursor(subscription) {\n    // XXX minimongo should not depend on mongo-livedata!\n    if (!Package.mongo) {\n      throw new Error('Can\\'t publish from Minimongo without the `mongo` package.');\n    }\n    if (!this.collection.name) {\n      throw new Error('Can\\'t publish a cursor from a collection without a name.');\n    }\n    return Package.mongo.Mongo.Collection._publishCursor(this, subscription, this.collection.name);\n  }\n}\n// Implements async version of cursor methods to keep collections isomorphic\nASYNC_CURSOR_METHODS.forEach(method => {\n  const asyncName = getAsyncMethodName(method);\n  Cursor.prototype[asyncName] = function () {\n    try {\n      this[method].isCalledFromAsync = true;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return Promise.resolve(this[method].apply(this, args));\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  };\n});","map":{"version":3,"names":["module","export","default","Cursor","LocalCollection","link","v","hasOwn","ASYNC_CURSOR_METHODS","getAsyncMethodName","constructor","collection","selector","options","sorter","matcher","Minimongo","Matcher","_selectorIsIdPerhapsAsObject","_selectorId","call","_id","undefined","hasGeoQuery","sort","Sorter","skip","limit","fields","projection","_projectionFn","_compileProjection","_transform","wrapTransform","transform","Tracker","reactive","count","_depend","added","removed","_getRawObjects","ordered","length","fetch","result","forEach","doc","push","Symbol","iterator","addedBefore","changed","movedBefore","index","objects","next","element","value","done","asyncIterator","syncResult","Promise","resolve","callback","thisArg","i","getTransform","map","observe","_observeFromObserveChanges","observeChanges","_observeChangesCallbacksAreOrdered","_allow_unordered","Error","distances","_IdMap","query","cursor","dirty","projectionFn","resultsSnapshot","qid","next_qid","queries","results","paused","wrapCallback","fn","self","args","arguments","_observeQueue","queueTask","apply","_suppress_initial","EJSON","clone","handle","Object","assign","ObserveHandle","stop","active","onInvalidate","drain","changers","dependency","Dependency","notify","bind","depend","_getCollectionName","name","applySkipLimit","selectedDoc","_docs","get","set","clear","id","matchResult","documentMatches","distance","getComparator","slice","_publishCursor","subscription","Package","mongo","Mongo","Collection","method","asyncName","prototype","isCalledFromAsync","error","reject"],"sources":["packages/minimongo/cursor.js"],"sourcesContent":["import LocalCollection from './local_collection.js';\nimport { hasOwn } from './common.js';\nimport { ASYNC_CURSOR_METHODS, getAsyncMethodName } from \"./constants\";\n\n// Cursor: a specification for a particular subset of documents, w/ a defined\n// order, limit, and offset.  creating a Cursor with LocalCollection.find(),\nexport default class Cursor {\n  // don't call this ctor directly.  use LocalCollection.find().\n  constructor(collection, selector, options = {}) {\n    this.collection = collection;\n    this.sorter = null;\n    this.matcher = new Minimongo.Matcher(selector);\n\n    if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n      // stash for fast _id and { _id }\n      this._selectorId = hasOwn.call(selector, '_id')\n        ? selector._id\n        : selector;\n    } else {\n      this._selectorId = undefined;\n\n      if (this.matcher.hasGeoQuery() || options.sort) {\n        this.sorter = new Minimongo.Sorter(options.sort || []);\n      }\n    }\n\n    this.skip = options.skip || 0;\n    this.limit = options.limit;\n    this.fields = options.projection || options.fields;\n\n    this._projectionFn = LocalCollection._compileProjection(this.fields || {});\n\n    this._transform = LocalCollection.wrapTransform(options.transform);\n\n    // by default, queries register w/ Tracker when it is available.\n    if (typeof Tracker !== 'undefined') {\n      this.reactive = options.reactive === undefined ? true : options.reactive;\n    }\n  }\n\n  /**\n   * @deprecated in 2.9\n   * @summary Returns the number of documents that match a query. This method is\n   *          [deprecated since MongoDB 4.0](https://www.mongodb.com/docs/v4.4/reference/command/count/);\n   *          see `Collection.countDocuments` and\n   *          `Collection.estimatedDocumentCount` for a replacement.\n   * @memberOf Mongo.Cursor\n   * @method  count\n   * @instance\n   * @locus Anywhere\n   * @returns {Number}\n   */\n  count() {\n    if (this.reactive) {\n      // allow the observe to be unordered\n      this._depend({added: true, removed: true}, true);\n    }\n\n    return this._getRawObjects({\n      ordered: true,\n    }).length;\n  }\n\n  /**\n   * @summary Return all matching documents as an Array.\n   * @memberOf Mongo.Cursor\n   * @method  fetch\n   * @instance\n   * @locus Anywhere\n   * @returns {Object[]}\n   */\n  fetch() {\n    const result = [];\n\n    this.forEach(doc => {\n      result.push(doc);\n    });\n\n    return result;\n  }\n\n  [Symbol.iterator]() {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true});\n    }\n\n    let index = 0;\n    const objects = this._getRawObjects({ordered: true});\n\n    return {\n      next: () => {\n        if (index < objects.length) {\n          // This doubles as a clone operation.\n          let element = this._projectionFn(objects[index++]);\n\n          if (this._transform)\n            element = this._transform(element);\n\n          return {value: element};\n        }\n\n        return {done: true};\n      }\n    };\n  }\n\n  [Symbol.asyncIterator]() {\n    const syncResult = this[Symbol.iterator]();\n    return {\n      async next() {\n        return Promise.resolve(syncResult.next());\n      }\n    };\n  }\n\n  /**\n   * @callback IterationCallback\n   * @param {Object} doc\n   * @param {Number} index\n   */\n  /**\n   * @summary Call `callback` once for each matching document, sequentially and\n   *          synchronously.\n   * @locus Anywhere\n   * @method  forEach\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  forEach(callback, thisArg) {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true});\n    }\n\n    this._getRawObjects({ordered: true}).forEach((element, i) => {\n      // This doubles as a clone operation.\n      element = this._projectionFn(element);\n\n      if (this._transform) {\n        element = this._transform(element);\n      }\n\n      callback.call(thisArg, element, i, this);\n    });\n  }\n\n  getTransform() {\n    return this._transform;\n  }\n\n  /**\n   * @summary Map callback over all matching documents.  Returns an Array.\n   * @locus Anywhere\n   * @method map\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  map(callback, thisArg) {\n    const result = [];\n\n    this.forEach((doc, i) => {\n      result.push(callback.call(thisArg, doc, i, this));\n    });\n\n    return result;\n  }\n\n  // options to contain:\n  //  * callbacks for observe():\n  //    - addedAt (document, atIndex)\n  //    - added (document)\n  //    - changedAt (newDocument, oldDocument, atIndex)\n  //    - changed (newDocument, oldDocument)\n  //    - removedAt (document, atIndex)\n  //    - removed (document)\n  //    - movedTo (document, oldIndex, newIndex)\n  //\n  // attributes available on returned query handle:\n  //  * stop(): end updates\n  //  * collection: the collection this query is querying\n  //\n  // iff x is a returned query handle, (x instanceof\n  // LocalCollection.ObserveHandle) is true\n  //\n  // initial results delivered through added callback\n  // XXX maybe callbacks should take a list of objects, to expose transactions?\n  // XXX maybe support field limiting (to limit what you're notified on)\n\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observe(options) {\n    return LocalCollection._observeFromObserveChanges(this, options);\n  }\n\n  /**\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\n   *          the differences between the old and new documents are passed to\n   *          the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observeChanges(options) {\n    const ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\n\n    // there are several places that assume you aren't combining skip/limit with\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n    // comment in _modifyAndNotify\n    // XXX allow skip/limit with unordered observe\n    if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\n      throw new Error(\n        \"Must use an ordered observe with skip or limit (i.e. 'addedBefore' \" +\n        \"for observeChanges or 'addedAt' for observe, instead of 'added').\"\n      );\n    }\n\n    if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\n      throw Error('You may not observe a cursor with {fields: {_id: 0}}');\n    }\n\n    const distances = (\n      this.matcher.hasGeoQuery() &&\n      ordered &&\n      new LocalCollection._IdMap\n    );\n\n    const query = {\n      cursor: this,\n      dirty: false,\n      distances,\n      matcher: this.matcher, // not fast pathed\n      ordered,\n      projectionFn: this._projectionFn,\n      resultsSnapshot: null,\n      sorter: ordered && this.sorter\n    };\n\n    let qid;\n\n    // Non-reactive queries call added[Before] and then never call anything\n    // else.\n    if (this.reactive) {\n      qid = this.collection.next_qid++;\n      this.collection.queries[qid] = query;\n    }\n\n    query.results = this._getRawObjects({ordered, distances: query.distances});\n\n    if (this.collection.paused) {\n      query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap;\n    }\n\n    // wrap callbacks we were passed. callbacks only fire when not paused and\n    // are never undefined\n    // Filters out blacklisted fields according to cursor's projection.\n    // XXX wrong place for this?\n\n    // furthermore, callbacks enqueue until the operation we're working on is\n    // done.\n    const wrapCallback = fn => {\n      if (!fn) {\n        return () => {};\n      }\n\n      const self = this;\n      return function(/* args*/) {\n        if (self.collection.paused) {\n          return;\n        }\n\n        const args = arguments;\n\n        self.collection._observeQueue.queueTask(() => {\n          fn.apply(this, args);\n        });\n      };\n    };\n\n    query.added = wrapCallback(options.added);\n    query.changed = wrapCallback(options.changed);\n    query.removed = wrapCallback(options.removed);\n\n    if (ordered) {\n      query.addedBefore = wrapCallback(options.addedBefore);\n      query.movedBefore = wrapCallback(options.movedBefore);\n    }\n\n    if (!options._suppress_initial && !this.collection.paused) {\n      query.results.forEach(doc => {\n        const fields = EJSON.clone(doc);\n\n        delete fields._id;\n\n        if (ordered) {\n          query.addedBefore(doc._id, this._projectionFn(fields), null);\n        }\n\n        query.added(doc._id, this._projectionFn(fields));\n      });\n    }\n\n    const handle = Object.assign(new LocalCollection.ObserveHandle, {\n      collection: this.collection,\n      stop: () => {\n        if (this.reactive) {\n          delete this.collection.queries[qid];\n        }\n      }\n    });\n\n    if (this.reactive && Tracker.active) {\n      // XXX in many cases, the same observe will be recreated when\n      // the current autorun is rerun.  we could save work by\n      // letting it linger across rerun and potentially get\n      // repurposed if the same observe is performed, using logic\n      // similar to that of Meteor.subscribe.\n      Tracker.onInvalidate(() => {\n        handle.stop();\n      });\n    }\n\n    // run the observe callbacks resulting from the initial contents\n    // before we leave the observe.\n    this.collection._observeQueue.drain();\n\n    return handle;\n  }\n\n  // XXX Maybe we need a version of observe that just calls a callback if\n  // anything changed.\n  _depend(changers, _allow_unordered) {\n    if (Tracker.active) {\n      const dependency = new Tracker.Dependency;\n      const notify = dependency.changed.bind(dependency);\n\n      dependency.depend();\n\n      const options = {_allow_unordered, _suppress_initial: true};\n\n      ['added', 'addedBefore', 'changed', 'movedBefore', 'removed']\n        .forEach(fn => {\n          if (changers[fn]) {\n            options[fn] = notify;\n          }\n        });\n\n      // observeChanges will stop() when this computation is invalidated\n      this.observeChanges(options);\n    }\n  }\n\n  _getCollectionName() {\n    return this.collection.name;\n  }\n\n  // Returns a collection of matching objects, but doesn't deep copy them.\n  //\n  // If ordered is set, returns a sorted array, respecting sorter, skip, and\n  // limit properties of the query provided that options.applySkipLimit is\n  // not set to false (#1201). If sorter is falsey, no sort -- you get the\n  // natural order.\n  //\n  // If ordered is not set, returns an object mapping from ID to doc (sorter,\n  // skip and limit should not be set).\n  //\n  // If ordered is set and this cursor is a $near geoquery, then this function\n  // will use an _IdMap to track each distance from the $near argument point in\n  // order to use it as a sort key. If an _IdMap is passed in the 'distances'\n  // argument, this function will clear it and use it for this purpose\n  // (otherwise it will just create its own _IdMap). The observeChanges\n  // implementation uses this to remember the distances after this function\n  // returns.\n  _getRawObjects(options = {}) {\n    // By default this method will respect skip and limit because .fetch(),\n    // .forEach() etc... expect this behaviour. It can be forced to ignore\n    // skip and limit by setting applySkipLimit to false (.count() does this,\n    // for example)\n    const applySkipLimit = options.applySkipLimit !== false;\n\n    // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n    // compatible\n    const results = options.ordered ? [] : new LocalCollection._IdMap;\n\n    // fast path for single ID value\n    if (this._selectorId !== undefined) {\n      // If you have non-zero skip and ask for a single id, you get nothing.\n      // This is so it matches the behavior of the '{_id: foo}' path.\n      if (applySkipLimit && this.skip) {\n        return results;\n      }\n\n      const selectedDoc = this.collection._docs.get(this._selectorId);\n\n      if (selectedDoc) {\n        if (options.ordered) {\n          results.push(selectedDoc);\n        } else {\n          results.set(this._selectorId, selectedDoc);\n        }\n      }\n\n      return results;\n    }\n\n    // slow path for arbitrary selector, sort, skip, limit\n\n    // in the observeChanges case, distances is actually part of the \"query\"\n    // (ie, live results set) object.  in other cases, distances is only used\n    // inside this function.\n    let distances;\n    if (this.matcher.hasGeoQuery() && options.ordered) {\n      if (options.distances) {\n        distances = options.distances;\n        distances.clear();\n      } else {\n        distances = new LocalCollection._IdMap();\n      }\n    }\n\n    this.collection._docs.forEach((doc, id) => {\n      const matchResult = this.matcher.documentMatches(doc);\n\n      if (matchResult.result) {\n        if (options.ordered) {\n          results.push(doc);\n\n          if (distances && matchResult.distance !== undefined) {\n            distances.set(id, matchResult.distance);\n          }\n        } else {\n          results.set(id, doc);\n        }\n      }\n\n      // Override to ensure all docs are matched if ignoring skip & limit\n      if (!applySkipLimit) {\n        return true;\n      }\n\n      // Fast path for limited unsorted queries.\n      // XXX 'length' check here seems wrong for ordered\n      return (\n        !this.limit ||\n        this.skip ||\n        this.sorter ||\n        results.length !== this.limit\n      );\n    });\n\n    if (!options.ordered) {\n      return results;\n    }\n\n    if (this.sorter) {\n      results.sort(this.sorter.getComparator({distances}));\n    }\n\n    // Return the full set of results if there is no skip or limit or if we're\n    // ignoring them\n    if (!applySkipLimit || (!this.limit && !this.skip)) {\n      return results;\n    }\n\n    return results.slice(\n      this.skip,\n      this.limit ? this.limit + this.skip : results.length\n    );\n  }\n\n  _publishCursor(subscription) {\n    // XXX minimongo should not depend on mongo-livedata!\n    if (!Package.mongo) {\n      throw new Error(\n        'Can\\'t publish from Minimongo without the `mongo` package.'\n      );\n    }\n\n    if (!this.collection.name) {\n      throw new Error(\n        'Can\\'t publish a cursor from a collection without a name.'\n      );\n    }\n\n    return Package.mongo.Mongo.Collection._publishCursor(\n      this,\n      subscription,\n      this.collection.name\n    );\n  }\n}\n\n// Implements async version of cursor methods to keep collections isomorphic\nASYNC_CURSOR_METHODS.forEach(method => {\n  const asyncName = getAsyncMethodName(method);\n  Cursor.prototype[asyncName] = function(...args) {\n    try {\n      this[method].isCalledFromAsync = true;\n      return Promise.resolve(this[method].apply(this, args));\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  };\n});\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"d49b4dff474c1fa6c1b0545b48d6eba292d0812d"}
