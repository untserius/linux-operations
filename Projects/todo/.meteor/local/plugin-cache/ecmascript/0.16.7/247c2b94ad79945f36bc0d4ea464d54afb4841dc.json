{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/serius/Desktop/Practicals/Projects/todo/packages/mongo/observe_multiplex.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/mongo/observe_multiplex.js","filename":"/home/serius/Desktop/Practicals/Projects/todo/packages/mongo/observe_multiplex.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/serius/Desktop/Practicals/Projects/todo","root":"/home/serius/Desktop/Practicals/Projects/todo","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/home/serius/Desktop/Practicals/Projects/todo/packages/mongo/observe_multiplex.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/observe_multiplex.js"}},"code":"const _excluded = [\"_id\"];\nlet _objectWithoutProperties;\nmodule.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n  default(v) {\n    _objectWithoutProperties = v;\n  }\n}, 0);\nvar Future = Npm.require('fibers/future');\nObserveMultiplexer = function (options) {\n  var self = this;\n  if (!options || !_.has(options, 'ordered')) throw Error(\"must specified ordered\");\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", 1);\n  self._ordered = options.ordered;\n  self._onStop = options.onStop || function () {};\n  self._queue = new Meteor._SynchronousQueue();\n  self._handles = {};\n  self._readyFuture = new Future();\n  self._cache = new LocalCollection._CachingChangeObserver({\n    ordered: options.ordered\n  });\n  // Number of addHandleAndSendInitialAdds tasks scheduled but not yet\n  // running. removeHandle uses this to know if it's time to call the onStop\n  // callback.\n  self._addHandleTasksScheduledButNotPerformed = 0;\n  _.each(self.callbackNames(), function (callbackName) {\n    self[callbackName] = function /* ... */\n    () {\n      self._applyCallback(callbackName, _.toArray(arguments));\n    };\n  });\n};\n_.extend(ObserveMultiplexer.prototype, {\n  addHandleAndSendInitialAdds: function (handle) {\n    var self = this;\n\n    // Check this before calling runTask (even though runTask does the same\n    // check) so that we don't leak an ObserveMultiplexer on error by\n    // incrementing _addHandleTasksScheduledButNotPerformed and never\n    // decrementing it.\n    if (!self._queue.safeToRunTask()) throw new Error(\"Can't call observeChanges from an observe callback on the same query\");\n    ++self._addHandleTasksScheduledButNotPerformed;\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", 1);\n    self._queue.runTask(function () {\n      self._handles[handle._id] = handle;\n      // Send out whatever adds we have so far (whether or not we the\n      // multiplexer is ready).\n      self._sendAdds(handle);\n      --self._addHandleTasksScheduledButNotPerformed;\n    });\n    // *outside* the task, since otherwise we'd deadlock\n    self._readyFuture.wait();\n  },\n  // Remove an observe handle. If it was the last observe handle, call the\n  // onStop callback; you cannot add any more observe handles after this.\n  //\n  // This is not synchronized with polls and handle additions: this means that\n  // you can safely call it from within an observe callback, but it also means\n  // that we have to be careful when we iterate over _handles.\n  removeHandle: function (id) {\n    var self = this;\n\n    // This should not be possible: you can only call removeHandle by having\n    // access to the ObserveHandle, which isn't returned to user code until the\n    // multiplex is ready.\n    if (!self._ready()) throw new Error(\"Can't remove handles until the multiplex is ready\");\n    delete self._handles[id];\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", -1);\n    if (_.isEmpty(self._handles) && self._addHandleTasksScheduledButNotPerformed === 0) {\n      self._stop();\n    }\n  },\n  _stop: function (options) {\n    var self = this;\n    options = options || {};\n\n    // It shouldn't be possible for us to stop when all our handles still\n    // haven't been returned from observeChanges!\n    if (!self._ready() && !options.fromQueryError) throw Error(\"surprising _stop: not ready\");\n\n    // Call stop callback (which kills the underlying process which sends us\n    // callbacks and removes us from the connection's dictionary).\n    self._onStop();\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", -1);\n\n    // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop\n    // callback should make our connection forget about us).\n    self._handles = null;\n  },\n  // Allows all addHandleAndSendInitialAdds calls to return, once all preceding\n  // adds have been processed. Does not block.\n  ready: function () {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (self._ready()) throw Error(\"can't make ObserveMultiplex ready twice!\");\n      self._readyFuture.return();\n    });\n  },\n  // If trying to execute the query results in an error, call this. This is\n  // intended for permanent errors, not transient network errors that could be\n  // fixed. It should only be called before ready(), because if you called ready\n  // that meant that you managed to run the query once. It will stop this\n  // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus\n  // observeChanges calls) to throw the error.\n  queryError: function (err) {\n    var self = this;\n    self._queue.runTask(function () {\n      if (self._ready()) throw Error(\"can't claim query has an error after it worked!\");\n      self._stop({\n        fromQueryError: true\n      });\n      self._readyFuture.throw(err);\n    });\n  },\n  // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"\n  // and observe callbacks which came before this call have been propagated to\n  // all handles. \"ready\" must have already been called on this multiplexer.\n  onFlush: function (cb) {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (!self._ready()) throw Error(\"only call onFlush on a multiplexer that will be ready\");\n      cb();\n    });\n  },\n  callbackNames: function () {\n    var self = this;\n    if (self._ordered) return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];else return [\"added\", \"changed\", \"removed\"];\n  },\n  _ready: function () {\n    return this._readyFuture.isResolved();\n  },\n  _applyCallback: function (callbackName, args) {\n    var self = this;\n    self._queue.queueTask(function () {\n      // If we stopped in the meantime, do nothing.\n      if (!self._handles) return;\n\n      // First, apply the change to the cache.\n      self._cache.applyChange[callbackName].apply(null, args);\n\n      // If we haven't finished the initial adds, then we should only be getting\n      // adds.\n      if (!self._ready() && callbackName !== 'added' && callbackName !== 'addedBefore') {\n        throw new Error(\"Got \" + callbackName + \" during initial adds\");\n      }\n\n      // Now multiplex the callbacks out to all observe handles. It's OK if\n      // these calls yield; since we're inside a task, no other use of our queue\n      // can continue until these are done. (But we do have to be careful to not\n      // use a handle that got removed, because removeHandle does not use the\n      // queue; thus, we iterate over an array of keys that we control.)\n      _.each(_.keys(self._handles), function (handleId) {\n        var handle = self._handles && self._handles[handleId];\n        if (!handle) return;\n        var callback = handle['_' + callbackName];\n        // clone arguments so that callbacks can mutate their arguments\n        callback && callback.apply(null, handle.nonMutatingCallbacks ? args : EJSON.clone(args));\n      });\n    });\n  },\n  // Sends initial adds to a handle. It should only be called from within a task\n  // (the task that is processing the addHandleAndSendInitialAdds call). It\n  // synchronously invokes the handle's added or addedBefore; there's no need to\n  // flush the queue afterwards to ensure that the callbacks get out.\n  _sendAdds: function (handle) {\n    var self = this;\n    if (self._queue.safeToRunTask()) throw Error(\"_sendAdds may only be called from within a task!\");\n    var add = self._ordered ? handle._addedBefore : handle._added;\n    if (!add) return;\n    // note: docs may be an _IdMap or an OrderedDict\n    self._cache.docs.forEach(function (doc, id) {\n      if (!_.has(self._handles, handle._id)) throw Error(\"handle got removed before sending initial adds!\");\n      const _ref = handle.nonMutatingCallbacks ? doc : EJSON.clone(doc),\n        {\n          _id\n        } = _ref,\n        fields = _objectWithoutProperties(_ref, _excluded);\n      if (self._ordered) add(id, fields, null); // we're going in order, so add at end\n      else add(id, fields);\n    });\n  }\n});\nvar nextObserveHandleId = 1;\n\n// When the callbacks do not mutate the arguments, we can skip a lot of data clones\nObserveHandle = function (multiplexer, callbacks) {\n  let nonMutatingCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var self = this;\n  // The end user is only supposed to call stop().  The other fields are\n  // accessible to the multiplexer, though.\n  self._multiplexer = multiplexer;\n  _.each(multiplexer.callbackNames(), function (name) {\n    if (callbacks[name]) {\n      self['_' + name] = callbacks[name];\n    } else if (name === \"addedBefore\" && callbacks.added) {\n      // Special case: if you specify \"added\" and \"movedBefore\", you get an\n      // ordered observe where for some reason you don't get ordering data on\n      // the adds.  I dunno, we wrote tests for it, there must have been a\n      // reason.\n      self._addedBefore = function (id, fields, before) {\n        callbacks.added(id, fields);\n      };\n    }\n  });\n  self._stopped = false;\n  self._id = nextObserveHandleId++;\n  self.nonMutatingCallbacks = nonMutatingCallbacks;\n};\nObserveHandle.prototype.stop = function () {\n  var self = this;\n  if (self._stopped) return;\n  self._stopped = true;\n  self._multiplexer.removeHandle(self._id);\n};","map":{"version":3,"names":["_objectWithoutProperties","module","link","default","v","Future","Npm","require","ObserveMultiplexer","options","self","_","has","Error","Package","Facts","incrementServerFact","_ordered","ordered","_onStop","onStop","_queue","Meteor","_SynchronousQueue","_handles","_readyFuture","_cache","LocalCollection","_CachingChangeObserver","_addHandleTasksScheduledButNotPerformed","each","callbackNames","callbackName","_applyCallback","toArray","arguments","extend","prototype","addHandleAndSendInitialAdds","handle","safeToRunTask","runTask","_id","_sendAdds","wait","removeHandle","id","_ready","isEmpty","_stop","fromQueryError","ready","queueTask","return","queryError","err","throw","onFlush","cb","isResolved","args","applyChange","apply","keys","handleId","callback","nonMutatingCallbacks","EJSON","clone","add","_addedBefore","_added","docs","forEach","doc","fields","nextObserveHandleId","ObserveHandle","multiplexer","callbacks","_multiplexer","name","added","before","_stopped","stop"],"sources":["packages/mongo/observe_multiplex.js"],"sourcesContent":["var Future = Npm.require('fibers/future');\n\nObserveMultiplexer = function (options) {\n  var self = this;\n\n  if (!options || !_.has(options, 'ordered'))\n    throw Error(\"must specified ordered\");\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-multiplexers\", 1);\n\n  self._ordered = options.ordered;\n  self._onStop = options.onStop || function () {};\n  self._queue = new Meteor._SynchronousQueue();\n  self._handles = {};\n  self._readyFuture = new Future;\n  self._cache = new LocalCollection._CachingChangeObserver({\n    ordered: options.ordered});\n  // Number of addHandleAndSendInitialAdds tasks scheduled but not yet\n  // running. removeHandle uses this to know if it's time to call the onStop\n  // callback.\n  self._addHandleTasksScheduledButNotPerformed = 0;\n\n  _.each(self.callbackNames(), function (callbackName) {\n    self[callbackName] = function (/* ... */) {\n      self._applyCallback(callbackName, _.toArray(arguments));\n    };\n  });\n};\n\n_.extend(ObserveMultiplexer.prototype, {\n  addHandleAndSendInitialAdds: function (handle) {\n    var self = this;\n\n    // Check this before calling runTask (even though runTask does the same\n    // check) so that we don't leak an ObserveMultiplexer on error by\n    // incrementing _addHandleTasksScheduledButNotPerformed and never\n    // decrementing it.\n    if (!self._queue.safeToRunTask())\n      throw new Error(\"Can't call observeChanges from an observe callback on the same query\");\n    ++self._addHandleTasksScheduledButNotPerformed;\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-handles\", 1);\n\n    self._queue.runTask(function () {\n      self._handles[handle._id] = handle;\n      // Send out whatever adds we have so far (whether or not we the\n      // multiplexer is ready).\n      self._sendAdds(handle);\n      --self._addHandleTasksScheduledButNotPerformed;\n    });\n    // *outside* the task, since otherwise we'd deadlock\n    self._readyFuture.wait();\n  },\n\n  // Remove an observe handle. If it was the last observe handle, call the\n  // onStop callback; you cannot add any more observe handles after this.\n  //\n  // This is not synchronized with polls and handle additions: this means that\n  // you can safely call it from within an observe callback, but it also means\n  // that we have to be careful when we iterate over _handles.\n  removeHandle: function (id) {\n    var self = this;\n\n    // This should not be possible: you can only call removeHandle by having\n    // access to the ObserveHandle, which isn't returned to user code until the\n    // multiplex is ready.\n    if (!self._ready())\n      throw new Error(\"Can't remove handles until the multiplex is ready\");\n\n    delete self._handles[id];\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-handles\", -1);\n\n    if (_.isEmpty(self._handles) &&\n        self._addHandleTasksScheduledButNotPerformed === 0) {\n      self._stop();\n    }\n  },\n  _stop: function (options) {\n    var self = this;\n    options = options || {};\n\n    // It shouldn't be possible for us to stop when all our handles still\n    // haven't been returned from observeChanges!\n    if (! self._ready() && ! options.fromQueryError)\n      throw Error(\"surprising _stop: not ready\");\n\n    // Call stop callback (which kills the underlying process which sends us\n    // callbacks and removes us from the connection's dictionary).\n    self._onStop();\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-multiplexers\", -1);\n\n    // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop\n    // callback should make our connection forget about us).\n    self._handles = null;\n  },\n\n  // Allows all addHandleAndSendInitialAdds calls to return, once all preceding\n  // adds have been processed. Does not block.\n  ready: function () {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (self._ready())\n        throw Error(\"can't make ObserveMultiplex ready twice!\");\n      self._readyFuture.return();\n    });\n  },\n\n  // If trying to execute the query results in an error, call this. This is\n  // intended for permanent errors, not transient network errors that could be\n  // fixed. It should only be called before ready(), because if you called ready\n  // that meant that you managed to run the query once. It will stop this\n  // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus\n  // observeChanges calls) to throw the error.\n  queryError: function (err) {\n    var self = this;\n    self._queue.runTask(function () {\n      if (self._ready())\n        throw Error(\"can't claim query has an error after it worked!\");\n      self._stop({fromQueryError: true});\n      self._readyFuture.throw(err);\n    });\n  },\n\n  // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"\n  // and observe callbacks which came before this call have been propagated to\n  // all handles. \"ready\" must have already been called on this multiplexer.\n  onFlush: function (cb) {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (!self._ready())\n        throw Error(\"only call onFlush on a multiplexer that will be ready\");\n      cb();\n    });\n  },\n  callbackNames: function () {\n    var self = this;\n    if (self._ordered)\n      return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];\n    else\n      return [\"added\", \"changed\", \"removed\"];\n  },\n  _ready: function () {\n    return this._readyFuture.isResolved();\n  },\n  _applyCallback: function (callbackName, args) {\n    var self = this;\n    self._queue.queueTask(function () {\n      // If we stopped in the meantime, do nothing.\n      if (!self._handles)\n        return;\n\n      // First, apply the change to the cache.\n      self._cache.applyChange[callbackName].apply(null, args);\n\n      // If we haven't finished the initial adds, then we should only be getting\n      // adds.\n      if (!self._ready() &&\n          (callbackName !== 'added' && callbackName !== 'addedBefore')) {\n        throw new Error(\"Got \" + callbackName + \" during initial adds\");\n      }\n\n      // Now multiplex the callbacks out to all observe handles. It's OK if\n      // these calls yield; since we're inside a task, no other use of our queue\n      // can continue until these are done. (But we do have to be careful to not\n      // use a handle that got removed, because removeHandle does not use the\n      // queue; thus, we iterate over an array of keys that we control.)\n      _.each(_.keys(self._handles), function (handleId) {\n        var handle = self._handles && self._handles[handleId];\n        if (!handle)\n          return;\n        var callback = handle['_' + callbackName];\n        // clone arguments so that callbacks can mutate their arguments\n        callback && callback.apply(null,\n          handle.nonMutatingCallbacks ? args : EJSON.clone(args));\n      });\n    });\n  },\n\n  // Sends initial adds to a handle. It should only be called from within a task\n  // (the task that is processing the addHandleAndSendInitialAdds call). It\n  // synchronously invokes the handle's added or addedBefore; there's no need to\n  // flush the queue afterwards to ensure that the callbacks get out.\n  _sendAdds: function (handle) {\n    var self = this;\n    if (self._queue.safeToRunTask())\n      throw Error(\"_sendAdds may only be called from within a task!\");\n    var add = self._ordered ? handle._addedBefore : handle._added;\n    if (!add)\n      return;\n    // note: docs may be an _IdMap or an OrderedDict\n    self._cache.docs.forEach(function (doc, id) {\n      if (!_.has(self._handles, handle._id))\n        throw Error(\"handle got removed before sending initial adds!\");\n      const { _id, ...fields } = handle.nonMutatingCallbacks ? doc\n        : EJSON.clone(doc);\n      if (self._ordered)\n        add(id, fields, null); // we're going in order, so add at end\n      else\n        add(id, fields);\n    });\n  }\n});\n\n\nvar nextObserveHandleId = 1;\n\n// When the callbacks do not mutate the arguments, we can skip a lot of data clones\nObserveHandle = function (multiplexer, callbacks, nonMutatingCallbacks = false) {\n  var self = this;\n  // The end user is only supposed to call stop().  The other fields are\n  // accessible to the multiplexer, though.\n  self._multiplexer = multiplexer;\n  _.each(multiplexer.callbackNames(), function (name) {\n    if (callbacks[name]) {\n      self['_' + name] = callbacks[name];\n    } else if (name === \"addedBefore\" && callbacks.added) {\n      // Special case: if you specify \"added\" and \"movedBefore\", you get an\n      // ordered observe where for some reason you don't get ordering data on\n      // the adds.  I dunno, we wrote tests for it, there must have been a\n      // reason.\n      self._addedBefore = function (id, fields, before) {\n        callbacks.added(id, fields);\n      };\n    }\n  });\n  self._stopped = false;\n  self._id = nextObserveHandleId++;\n  self.nonMutatingCallbacks = nonMutatingCallbacks;\n};\nObserveHandle.prototype.stop = function () {\n  var self = this;\n  if (self._stopped)\n    return;\n  self._stopped = true;\n  self._multiplexer.removeHandle(self._id);\n};\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"247c2b94ad79945f36bc0d4ea464d54afb4841dc"}
