{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/serius/Desktop/Practicals/Projects/todo/packages/ddp-server/livedata_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/ddp-server/livedata_server.js","filename":"/home/serius/Desktop/Practicals/Projects/todo/packages/ddp-server/livedata_server.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/home/serius/Desktop/Practicals/Projects/todo","root":"/home/serius/Desktop/Practicals/Projects/todo","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"_exploded":{},"_verified":{},"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"/home/serius/Desktop/Practicals/Projects/todo/packages/ddp-server/livedata_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/ddp-server/livedata_server.js"}},"code":"let _objectSpread;\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n}, 0);\nDDPServer = {};\nvar Fiber = Npm.require('fibers');\n\n// Publication strategies define how we handle data from published cursors at the collection level\n// This allows someone to:\n// - Choose a trade-off between client-server bandwidth and server memory usage\n// - Implement special (non-mongo) collections like volatile message queues\nconst publicationStrategies = {\n  // SERVER_MERGE is the default strategy.\n  // When using this strategy, the server maintains a copy of all data a connection is subscribed to.\n  // This allows us to only send deltas over multiple publications.\n  SERVER_MERGE: {\n    useCollectionView: true,\n    doAccountingForCollection: true\n  },\n  // The NO_MERGE_NO_HISTORY strategy results in the server sending all publication data\n  // directly to the client. It does not remember what it has previously sent\n  // to it will not trigger removed messages when a subscription is stopped.\n  // This should only be chosen for special use cases like send-and-forget queues.\n  NO_MERGE_NO_HISTORY: {\n    useCollectionView: false,\n    doAccountingForCollection: false\n  },\n  // NO_MERGE is similar to NO_MERGE_NO_HISTORY but the server will remember the IDs it has\n  // sent to the client so it can remove them when a subscription is stopped.\n  // This strategy can be used when a collection is only used in a single publication.\n  NO_MERGE: {\n    useCollectionView: false,\n    doAccountingForCollection: true\n  }\n};\nDDPServer.publicationStrategies = publicationStrategies;\n\n// This file contains classes:\n// * Session - The server's connection to a single DDP client\n// * Subscription - A single subscription for a single client\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\n//\n// Session and Subscription are file scope. For now, until we freeze\n// the interface, Server is package scope (in the future it should be\n// exported).\n\n// Represents a single document in a SessionCollectionView\nvar SessionDocumentView = function () {\n  var self = this;\n  self.existsIn = new Set(); // set of subscriptionHandle\n  self.dataByKey = new Map(); // key-> [ {subscriptionHandle, value} by precedence]\n};\n\nDDPServer._SessionDocumentView = SessionDocumentView;\n_.extend(SessionDocumentView.prototype, {\n  getFields: function () {\n    var self = this;\n    var ret = {};\n    self.dataByKey.forEach(function (precedenceList, key) {\n      ret[key] = precedenceList[0].value;\n    });\n    return ret;\n  },\n  clearField: function (subscriptionHandle, key, changeCollector) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\") return;\n    var precedenceList = self.dataByKey.get(key);\n\n    // It's okay to clear fields that didn't exist. No need to throw\n    // an error.\n    if (!precedenceList) return;\n    var removedValue = undefined;\n    for (var i = 0; i < precedenceList.length; i++) {\n      var precedence = precedenceList[i];\n      if (precedence.subscriptionHandle === subscriptionHandle) {\n        // The view's value can only change if this subscription is the one that\n        // used to have precedence.\n        if (i === 0) removedValue = precedence.value;\n        precedenceList.splice(i, 1);\n        break;\n      }\n    }\n    if (precedenceList.length === 0) {\n      self.dataByKey.delete(key);\n      changeCollector[key] = undefined;\n    } else if (removedValue !== undefined && !EJSON.equals(removedValue, precedenceList[0].value)) {\n      changeCollector[key] = precedenceList[0].value;\n    }\n  },\n  changeField: function (subscriptionHandle, key, value, changeCollector, isAdd) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\") return;\n\n    // Don't share state with the data passed in by the user.\n    value = EJSON.clone(value);\n    if (!self.dataByKey.has(key)) {\n      self.dataByKey.set(key, [{\n        subscriptionHandle: subscriptionHandle,\n        value: value\n      }]);\n      changeCollector[key] = value;\n      return;\n    }\n    var precedenceList = self.dataByKey.get(key);\n    var elt;\n    if (!isAdd) {\n      elt = precedenceList.find(function (precedence) {\n        return precedence.subscriptionHandle === subscriptionHandle;\n      });\n    }\n    if (elt) {\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n        // this subscription is changing the value of this field.\n        changeCollector[key] = value;\n      }\n      elt.value = value;\n    } else {\n      // this subscription is newly caring about this field\n      precedenceList.push({\n        subscriptionHandle: subscriptionHandle,\n        value: value\n      });\n    }\n  }\n});\n\n/**\n * Represents a client's view of a single collection\n * @param {String} collectionName Name of the collection it represents\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed\n * @class SessionCollectionView\n */\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.documents = new Map();\n  self.callbacks = sessionCallbacks;\n};\nDDPServer._SessionCollectionView = SessionCollectionView;\nObject.assign(SessionCollectionView.prototype, {\n  isEmpty: function () {\n    var self = this;\n    return self.documents.size === 0;\n  },\n  diff: function (previous) {\n    var self = this;\n    DiffSequence.diffMaps(previous.documents, self.documents, {\n      both: _.bind(self.diffDocument, self),\n      rightOnly: function (id, nowDV) {\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());\n      },\n      leftOnly: function (id, prevDV) {\n        self.callbacks.removed(self.collectionName, id);\n      }\n    });\n  },\n  diffDocument: function (id, prevDV, nowDV) {\n    var self = this;\n    var fields = {};\n    DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {\n      both: function (key, prev, now) {\n        if (!EJSON.equals(prev, now)) fields[key] = now;\n      },\n      rightOnly: function (key, now) {\n        fields[key] = now;\n      },\n      leftOnly: function (key, prev) {\n        fields[key] = undefined;\n      }\n    });\n    self.callbacks.changed(self.collectionName, id, fields);\n  },\n  added: function (subscriptionHandle, id, fields) {\n    var self = this;\n    var docView = self.documents.get(id);\n    var added = false;\n    if (!docView) {\n      added = true;\n      docView = new SessionDocumentView();\n      self.documents.set(id, docView);\n    }\n    docView.existsIn.add(subscriptionHandle);\n    var changeCollector = {};\n    _.each(fields, function (value, key) {\n      docView.changeField(subscriptionHandle, key, value, changeCollector, true);\n    });\n    if (added) self.callbacks.added(self.collectionName, id, changeCollector);else self.callbacks.changed(self.collectionName, id, changeCollector);\n  },\n  changed: function (subscriptionHandle, id, changed) {\n    var self = this;\n    var changedResult = {};\n    var docView = self.documents.get(id);\n    if (!docView) throw new Error(\"Could not find element with id \" + id + \" to change\");\n    _.each(changed, function (value, key) {\n      if (value === undefined) docView.clearField(subscriptionHandle, key, changedResult);else docView.changeField(subscriptionHandle, key, value, changedResult);\n    });\n    self.callbacks.changed(self.collectionName, id, changedResult);\n  },\n  removed: function (subscriptionHandle, id) {\n    var self = this;\n    var docView = self.documents.get(id);\n    if (!docView) {\n      var err = new Error(\"Removed nonexistent document \" + id);\n      throw err;\n    }\n    docView.existsIn.delete(subscriptionHandle);\n    if (docView.existsIn.size === 0) {\n      // it is gone from everyone\n      self.callbacks.removed(self.collectionName, id);\n      self.documents.delete(id);\n    } else {\n      var changed = {};\n      // remove this subscription from every precedence list\n      // and record the changes\n      docView.dataByKey.forEach(function (precedenceList, key) {\n        docView.clearField(subscriptionHandle, key, changed);\n      });\n      self.callbacks.changed(self.collectionName, id, changed);\n    }\n  }\n});\n\n/******************************************************************************/\n/* Session                                                                    */\n/******************************************************************************/\n\nvar Session = function (server, version, socket, options) {\n  var self = this;\n  self.id = Random.id();\n  self.server = server;\n  self.version = version;\n  self.initialized = false;\n  self.socket = socket;\n\n  // Set to null when the session is destroyed. Multiple places below\n  // use this to determine if the session is alive or not.\n  self.inQueue = new Meteor._DoubleEndedQueue();\n  self.blocked = false;\n  self.workerRunning = false;\n  self.cachedUnblock = null;\n\n  // Sub objects for active subscriptions\n  self._namedSubs = new Map();\n  self._universalSubs = [];\n  self.userId = null;\n  self.collectionViews = new Map();\n\n  // Set this to false to not send messages when collectionViews are\n  // modified. This is done when rerunning subs in _setUserId and those messages\n  // are calculated via a diff instead.\n  self._isSending = true;\n\n  // If this is true, don't start a newly-created universal publisher on this\n  // session. The session will take care of starting it when appropriate.\n  self._dontStartNewUniversalSubs = false;\n\n  // When we are rerunning subscriptions, any ready messages\n  // we want to buffer up for when we are done rerunning subscriptions\n  self._pendingReady = [];\n\n  // List of callbacks to call when this connection is closed.\n  self._closeCallbacks = [];\n\n  // XXX HACK: If a sockjs connection, save off the URL. This is\n  // temporary and will go away in the near future.\n  self._socketUrl = socket.url;\n\n  // Allow tests to disable responding to pings.\n  self._respondToPings = options.respondToPings;\n\n  // This object is the public interface to the session. In the public\n  // API, it is called the `connection` object.  Internally we call it\n  // a `connectionHandle` to avoid ambiguity.\n  self.connectionHandle = {\n    id: self.id,\n    close: function () {\n      self.close();\n    },\n    onClose: function (fn) {\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\n      if (self.inQueue) {\n        self._closeCallbacks.push(cb);\n      } else {\n        // if we're already closed, call the callback.\n        Meteor.defer(cb);\n      }\n    },\n    clientAddress: self._clientAddress(),\n    httpHeaders: self.socket.headers\n  };\n  self.send({\n    msg: 'connected',\n    session: self.id\n  });\n\n  // On initial connect, spin up all the universal publishers.\n  Fiber(function () {\n    self.startUniversalSubs();\n  }).run();\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n    // We no longer need the low level timeout because we have heartbeats.\n    socket.setWebsocketTimeout(0);\n    self.heartbeat = new DDPCommon.Heartbeat({\n      heartbeatInterval: options.heartbeatInterval,\n      heartbeatTimeout: options.heartbeatTimeout,\n      onTimeout: function () {\n        self.close();\n      },\n      sendPing: function () {\n        self.send({\n          msg: 'ping'\n        });\n      }\n    });\n    self.heartbeat.start();\n  }\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"sessions\", 1);\n};\nObject.assign(Session.prototype, {\n  sendReady: function (subscriptionIds) {\n    var self = this;\n    if (self._isSending) self.send({\n      msg: \"ready\",\n      subs: subscriptionIds\n    });else {\n      _.each(subscriptionIds, function (subscriptionId) {\n        self._pendingReady.push(subscriptionId);\n      });\n    }\n  },\n  _canSend(collectionName) {\n    return this._isSending || !this.server.getPublicationStrategy(collectionName).useCollectionView;\n  },\n  sendAdded(collectionName, id, fields) {\n    if (this._canSend(collectionName)) this.send({\n      msg: \"added\",\n      collection: collectionName,\n      id,\n      fields\n    });\n  },\n  sendChanged(collectionName, id, fields) {\n    if (_.isEmpty(fields)) return;\n    if (this._canSend(collectionName)) {\n      this.send({\n        msg: \"changed\",\n        collection: collectionName,\n        id,\n        fields\n      });\n    }\n  },\n  sendRemoved(collectionName, id) {\n    if (this._canSend(collectionName)) this.send({\n      msg: \"removed\",\n      collection: collectionName,\n      id\n    });\n  },\n  getSendCallbacks: function () {\n    var self = this;\n    return {\n      added: _.bind(self.sendAdded, self),\n      changed: _.bind(self.sendChanged, self),\n      removed: _.bind(self.sendRemoved, self)\n    };\n  },\n  getCollectionView: function (collectionName) {\n    var self = this;\n    var ret = self.collectionViews.get(collectionName);\n    if (!ret) {\n      ret = new SessionCollectionView(collectionName, self.getSendCallbacks());\n      self.collectionViews.set(collectionName, ret);\n    }\n    return ret;\n  },\n  added(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.added(subscriptionHandle, id, fields);\n    } else {\n      this.sendAdded(collectionName, id, fields);\n    }\n  },\n  removed(subscriptionHandle, collectionName, id) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.removed(subscriptionHandle, id);\n      if (view.isEmpty()) {\n        this.collectionViews.delete(collectionName);\n      }\n    } else {\n      this.sendRemoved(collectionName, id);\n    }\n  },\n  changed(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.changed(subscriptionHandle, id, fields);\n    } else {\n      this.sendChanged(collectionName, id, fields);\n    }\n  },\n  startUniversalSubs: function () {\n    var self = this;\n    // Make a shallow copy of the set of universal handlers and start them. If\n    // additional universal publishers start while we're running them (due to\n    // yielding), they will run separately as part of Server.publish.\n    var handlers = _.clone(self.server.universal_publish_handlers);\n    _.each(handlers, function (handler) {\n      self._startSubscription(handler);\n    });\n  },\n  // Destroy this session and unregister it at the server.\n  close: function () {\n    var self = this;\n\n    // Destroy this session, even if it's not registered at the\n    // server. Stop all processing and tear everything down. If a socket\n    // was attached, close it.\n\n    // Already destroyed.\n    if (!self.inQueue) return;\n\n    // Drop the merge box data immediately.\n    self.inQueue = null;\n    self.collectionViews = new Map();\n    if (self.heartbeat) {\n      self.heartbeat.stop();\n      self.heartbeat = null;\n    }\n    if (self.socket) {\n      self.socket.close();\n      self.socket._meteorSession = null;\n    }\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"sessions\", -1);\n    Meteor.defer(function () {\n      // Stop callbacks can yield, so we defer this on close.\n      // sub._isDeactivated() detects that we set inQueue to null and\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\n      self._deactivateAllSubscriptions();\n\n      // Defer calling the close callbacks, so that the caller closing\n      // the session isn't waiting for all the callbacks to complete.\n      _.each(self._closeCallbacks, function (callback) {\n        callback();\n      });\n    });\n\n    // Unregister the session.\n    self.server._removeSession(self);\n  },\n  // Send a message (doing nothing if no socket is connected right now).\n  // It should be a JSON object (it will be stringified).\n  send: function (msg) {\n    var self = this;\n    if (self.socket) {\n      if (Meteor._printSentDDP) Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));\n      self.socket.send(DDPCommon.stringifyDDP(msg));\n    }\n  },\n  // Send a connection error.\n  sendError: function (reason, offendingMessage) {\n    var self = this;\n    var msg = {\n      msg: 'error',\n      reason: reason\n    };\n    if (offendingMessage) msg.offendingMessage = offendingMessage;\n    self.send(msg);\n  },\n  // Process 'msg' as an incoming message. As a guard against\n  // race conditions during reconnection, ignore the message if\n  // 'socket' is not the currently connected socket.\n  //\n  // We run the messages from the client one at a time, in the order\n  // given by the client. The message handler is passed an idempotent\n  // function 'unblock' which it may call to allow other messages to\n  // begin running in parallel in another fiber (for example, a method\n  // that wants to yield). Otherwise, it is automatically unblocked\n  // when it returns.\n  //\n  // Actually, we don't have to 'totally order' the messages in this\n  // way, but it's the easiest thing that's correct. (unsub needs to\n  // be ordered against sub, methods need to be ordered against each\n  // other).\n  processMessage: function (msg_in) {\n    var self = this;\n    if (!self.inQueue)\n      // we have been destroyed.\n      return;\n\n    // Respond to ping and pong messages immediately without queuing.\n    // If the negotiated DDP version is \"pre1\" which didn't support\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad\n    // request\" for the unknown messages.\n    //\n    // Fibers are needed because heartbeats use Meteor.setTimeout, which\n    // needs a Fiber. We could actually use regular setTimeout and avoid\n    // these new fibers, but it is easier to just make everything use\n    // Meteor.setTimeout and not think too hard.\n    //\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the client is still alive.\n    if (self.heartbeat) {\n      Fiber(function () {\n        self.heartbeat.messageReceived();\n      }).run();\n    }\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n      if (self._respondToPings) self.send({\n        msg: \"pong\",\n        id: msg_in.id\n      });\n      return;\n    }\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n      // Since everything is a pong, there is nothing to do\n      return;\n    }\n    self.inQueue.push(msg_in);\n    if (self.workerRunning) return;\n    self.workerRunning = true;\n    var processNext = function () {\n      var msg = self.inQueue && self.inQueue.shift();\n      if (!msg) {\n        self.workerRunning = false;\n        return;\n      }\n      Fiber(function () {\n        var blocked = true;\n        var unblock = function () {\n          if (!blocked) return; // idempotent\n          blocked = false;\n          processNext();\n        };\n        self.server.onMessageHook.each(function (callback) {\n          callback(msg, self);\n          return true;\n        });\n        if (_.has(self.protocol_handlers, msg.msg)) self.protocol_handlers[msg.msg].call(self, msg, unblock);else self.sendError('Bad request', msg);\n        unblock(); // in case the handler didn't already do it\n      }).run();\n    };\n    processNext();\n  },\n  protocol_handlers: {\n    sub: function (msg, unblock) {\n      var self = this;\n\n      // cacheUnblock temporarly, so we can capture it later\n      // we will use unblock in current eventLoop, so this is safe\n      self.cachedUnblock = unblock;\n\n      // reject malformed messages\n      if (typeof msg.id !== \"string\" || typeof msg.name !== \"string\" || 'params' in msg && !(msg.params instanceof Array)) {\n        self.sendError(\"Malformed subscription\", msg);\n        return;\n      }\n      if (!self.server.publish_handlers[msg.name]) {\n        self.send({\n          msg: 'nosub',\n          id: msg.id,\n          error: new Meteor.Error(404, \"Subscription '\".concat(msg.name, \"' not found\"))\n        });\n        return;\n      }\n      if (self._namedSubs.has(msg.id))\n        // subs are idempotent, or rather, they are ignored if a sub\n        // with that id already exists. this is important during\n        // reconnect.\n        return;\n\n      // XXX It'd be much better if we had generic hooks where any package can\n      // hook into subscription handling, but in the mean while we special case\n      // ddp-rate-limiter package. This is also done for weak requirements to\n      // add the ddp-rate-limiter package in case we don't have Accounts. A\n      // user trying to use the ddp-rate-limiter must explicitly require it.\n      if (Package['ddp-rate-limiter']) {\n        var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n        var rateLimiterInput = {\n          userId: self.userId,\n          clientAddress: self.connectionHandle.clientAddress,\n          type: \"subscription\",\n          name: msg.name,\n          connectionId: self.id\n        };\n        DDPRateLimiter._increment(rateLimiterInput);\n        var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n        if (!rateLimitResult.allowed) {\n          self.send({\n            msg: 'nosub',\n            id: msg.id,\n            error: new Meteor.Error('too-many-requests', DDPRateLimiter.getErrorMessage(rateLimitResult), {\n              timeToReset: rateLimitResult.timeToReset\n            })\n          });\n          return;\n        }\n      }\n      var handler = self.server.publish_handlers[msg.name];\n      self._startSubscription(handler, msg.id, msg.params, msg.name);\n\n      // cleaning cached unblock\n      self.cachedUnblock = null;\n    },\n    unsub: function (msg) {\n      var self = this;\n      self._stopSubscription(msg.id);\n    },\n    method: function (msg, unblock) {\n      var self = this;\n\n      // Reject malformed messages.\n      // For now, we silently ignore unknown attributes,\n      // for forwards compatibility.\n      if (typeof msg.id !== \"string\" || typeof msg.method !== \"string\" || 'params' in msg && !(msg.params instanceof Array) || 'randomSeed' in msg && typeof msg.randomSeed !== \"string\") {\n        self.sendError(\"Malformed method invocation\", msg);\n        return;\n      }\n      var randomSeed = msg.randomSeed || null;\n\n      // Set up to mark the method as satisfied once all observers\n      // (and subscriptions) have reacted to any writes that were\n      // done.\n      var fence = new DDPServer._WriteFence();\n      fence.onAllCommitted(function () {\n        // Retire the fence so that future writes are allowed.\n        // This means that callbacks like timers are free to use\n        // the fence, and if they fire before it's armed (for\n        // example, because the method waits for them) their\n        // writes will be included in the fence.\n        fence.retire();\n        self.send({\n          msg: 'updated',\n          methods: [msg.id]\n        });\n      });\n\n      // Find the handler\n      var handler = self.server.method_handlers[msg.method];\n      if (!handler) {\n        self.send({\n          msg: 'result',\n          id: msg.id,\n          error: new Meteor.Error(404, \"Method '\".concat(msg.method, \"' not found\"))\n        });\n        fence.arm();\n        return;\n      }\n      var setUserId = function (userId) {\n        self._setUserId(userId);\n      };\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: false,\n        userId: self.userId,\n        setUserId: setUserId,\n        unblock: unblock,\n        connection: self.connectionHandle,\n        randomSeed: randomSeed\n      });\n      const promise = new Promise((resolve, reject) => {\n        // XXX It'd be better if we could hook into method handlers better but\n        // for now, we need to check if the ddp-rate-limiter exists since we\n        // have a weak requirement for the ddp-rate-limiter package to be added\n        // to our application.\n        if (Package['ddp-rate-limiter']) {\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n          var rateLimiterInput = {\n            userId: self.userId,\n            clientAddress: self.connectionHandle.clientAddress,\n            type: \"method\",\n            name: msg.method,\n            connectionId: self.id\n          };\n          DDPRateLimiter._increment(rateLimiterInput);\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n          if (!rateLimitResult.allowed) {\n            reject(new Meteor.Error(\"too-many-requests\", DDPRateLimiter.getErrorMessage(rateLimitResult), {\n              timeToReset: rateLimitResult.timeToReset\n            }));\n            return;\n          }\n        }\n        const getCurrentMethodInvocationResult = () => {\n          const currentContext = DDP._CurrentMethodInvocation._setNewContextAndGetCurrent(invocation);\n          try {\n            let result;\n            const resultOrThenable = maybeAuditArgumentChecks(handler, invocation, msg.params, \"call to '\" + msg.method + \"'\");\n            const isThenable = resultOrThenable && typeof resultOrThenable.then === 'function';\n            if (isThenable) {\n              result = Promise.await(resultOrThenable);\n            } else {\n              result = resultOrThenable;\n            }\n            return result;\n          } finally {\n            DDP._CurrentMethodInvocation._set(currentContext);\n          }\n        };\n        resolve(DDPServer._CurrentWriteFence.withValue(fence, getCurrentMethodInvocationResult));\n      });\n      function finish() {\n        fence.arm();\n        unblock();\n      }\n      const payload = {\n        msg: \"result\",\n        id: msg.id\n      };\n      promise.then(result => {\n        finish();\n        if (result !== undefined) {\n          payload.result = result;\n        }\n        self.send(payload);\n      }, exception => {\n        finish();\n        payload.error = wrapInternalException(exception, \"while invoking method '\".concat(msg.method, \"'\"));\n        self.send(payload);\n      });\n    }\n  },\n  _eachSub: function (f) {\n    var self = this;\n    self._namedSubs.forEach(f);\n    self._universalSubs.forEach(f);\n  },\n  _diffCollectionViews: function (beforeCVs) {\n    var self = this;\n    DiffSequence.diffMaps(beforeCVs, self.collectionViews, {\n      both: function (collectionName, leftValue, rightValue) {\n        rightValue.diff(leftValue);\n      },\n      rightOnly: function (collectionName, rightValue) {\n        rightValue.documents.forEach(function (docView, id) {\n          self.sendAdded(collectionName, id, docView.getFields());\n        });\n      },\n      leftOnly: function (collectionName, leftValue) {\n        leftValue.documents.forEach(function (doc, id) {\n          self.sendRemoved(collectionName, id);\n        });\n      }\n    });\n  },\n  // Sets the current user id in all appropriate contexts and reruns\n  // all subscriptions\n  _setUserId: function (userId) {\n    var self = this;\n    if (userId !== null && typeof userId !== \"string\") throw new Error(\"setUserId must be called on string or null, not \" + typeof userId);\n\n    // Prevent newly-created universal subscriptions from being added to our\n    // session. They will be found below when we call startUniversalSubs.\n    //\n    // (We don't have to worry about named subscriptions, because we only add\n    // them when we process a 'sub' message. We are currently processing a\n    // 'method' message, and the method did not unblock, because it is illegal\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a\n    // new named subscription).\n    self._dontStartNewUniversalSubs = true;\n\n    // Prevent current subs from updating our collectionViews and call their\n    // stop callbacks. This may yield.\n    self._eachSub(function (sub) {\n      sub._deactivate();\n    });\n\n    // All subs should now be deactivated. Stop sending messages to the client,\n    // save the state of the published collections, reset to an empty view, and\n    // update the userId.\n    self._isSending = false;\n    var beforeCVs = self.collectionViews;\n    self.collectionViews = new Map();\n    self.userId = userId;\n\n    // _setUserId is normally called from a Meteor method with\n    // DDP._CurrentMethodInvocation set. But DDP._CurrentMethodInvocation is not\n    // expected to be set inside a publish function, so we temporary unset it.\n    // Inside a publish function DDP._CurrentPublicationInvocation is set.\n    DDP._CurrentMethodInvocation.withValue(undefined, function () {\n      // Save the old named subs, and reset to having no subscriptions.\n      var oldNamedSubs = self._namedSubs;\n      self._namedSubs = new Map();\n      self._universalSubs = [];\n      oldNamedSubs.forEach(function (sub, subscriptionId) {\n        var newSub = sub._recreate();\n        self._namedSubs.set(subscriptionId, newSub);\n        // nb: if the handler throws or calls this.error(), it will in fact\n        // immediately send its 'nosub'. This is OK, though.\n        newSub._runHandler();\n      });\n\n      // Allow newly-created universal subs to be started on our connection in\n      // parallel with the ones we're spinning up here, and spin up universal\n      // subs.\n      self._dontStartNewUniversalSubs = false;\n      self.startUniversalSubs();\n    });\n\n    // Start sending messages again, beginning with the diff from the previous\n    // state of the world to the current state. No yields are allowed during\n    // this diff, so that other changes cannot interleave.\n    Meteor._noYieldsAllowed(function () {\n      self._isSending = true;\n      self._diffCollectionViews(beforeCVs);\n      if (!_.isEmpty(self._pendingReady)) {\n        self.sendReady(self._pendingReady);\n        self._pendingReady = [];\n      }\n    });\n  },\n  _startSubscription: function (handler, subId, params, name) {\n    var self = this;\n    var sub = new Subscription(self, handler, subId, params, name);\n    let unblockHander = self.cachedUnblock;\n    // _startSubscription may call from a lot places\n    // so cachedUnblock might be null in somecases\n    // assign the cachedUnblock\n    sub.unblock = unblockHander || (() => {});\n    if (subId) self._namedSubs.set(subId, sub);else self._universalSubs.push(sub);\n    sub._runHandler();\n  },\n  // Tear down specified subscription\n  _stopSubscription: function (subId, error) {\n    var self = this;\n    var subName = null;\n    if (subId) {\n      var maybeSub = self._namedSubs.get(subId);\n      if (maybeSub) {\n        subName = maybeSub._name;\n        maybeSub._removeAllDocuments();\n        maybeSub._deactivate();\n        self._namedSubs.delete(subId);\n      }\n    }\n    var response = {\n      msg: 'nosub',\n      id: subId\n    };\n    if (error) {\n      response.error = wrapInternalException(error, subName ? \"from sub \" + subName + \" id \" + subId : \"from sub id \" + subId);\n    }\n    self.send(response);\n  },\n  // Tear down all subscriptions. Note that this does NOT send removed or nosub\n  // messages, since we assume the client is gone.\n  _deactivateAllSubscriptions: function () {\n    var self = this;\n    self._namedSubs.forEach(function (sub, id) {\n      sub._deactivate();\n    });\n    self._namedSubs = new Map();\n    self._universalSubs.forEach(function (sub) {\n      sub._deactivate();\n    });\n    self._universalSubs = [];\n  },\n  // Determine the remote client's IP address, based on the\n  // HTTP_FORWARDED_COUNT environment variable representing how many\n  // proxies the server is behind.\n  _clientAddress: function () {\n    var self = this;\n\n    // For the reported client address for a connection to be correct,\n    // the developer must set the HTTP_FORWARDED_COUNT environment\n    // variable to an integer representing the number of hops they\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\n    // server is behind one proxy.\n    //\n    // This could be computed once at startup instead of every time.\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\n    if (httpForwardedCount === 0) return self.socket.remoteAddress;\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\n    if (!_.isString(forwardedFor)) return null;\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);\n\n    // Typically the first value in the `x-forwarded-for` header is\n    // the original IP address of the client connecting to the first\n    // proxy.  However, the end user can easily spoof the header, in\n    // which case the first value(s) will be the fake IP address from\n    // the user pretending to be a proxy reporting the original IP\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the\n    // end of the list, we ensure that we get the IP address being\n    // reported by *our* first proxy.\n\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length) return null;\n    return forwardedFor[forwardedFor.length - httpForwardedCount];\n  }\n});\n\n/******************************************************************************/\n/* Subscription                                                               */\n/******************************************************************************/\n\n// Ctor for a sub handle: the input to each publish function\n\n// Instance name is this because it's usually referred to as this inside a\n// publish\n/**\n * @summary The server's side of a subscription\n * @class Subscription\n * @instanceName this\n * @showInstanceName true\n */\nvar Subscription = function (session, handler, subscriptionId, params, name) {\n  var self = this;\n  self._session = session; // type is Session\n\n  /**\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server\n   * @name  connection\n   * @memberOf Subscription\n   * @instance\n   */\n  self.connection = session.connectionHandle; // public API object\n\n  self._handler = handler;\n\n  // My subscription ID (generated by client, undefined for universal subs).\n  self._subscriptionId = subscriptionId;\n  // Undefined for universal subs\n  self._name = name;\n  self._params = params || [];\n\n  // Only named subscriptions have IDs, but we need some sort of string\n  // internally to keep track of all subscriptions inside\n  // SessionDocumentViews. We use this subscriptionHandle for that.\n  if (self._subscriptionId) {\n    self._subscriptionHandle = 'N' + self._subscriptionId;\n  } else {\n    self._subscriptionHandle = 'U' + Random.id();\n  }\n\n  // Has _deactivate been called?\n  self._deactivated = false;\n\n  // Stop callbacks to g/c this sub.  called w/ zero arguments.\n  self._stopCallbacks = [];\n\n  // The set of (collection, documentid) that this subscription has\n  // an opinion about.\n  self._documents = new Map();\n\n  // Remember if we are ready.\n  self._ready = false;\n\n  // Part of the public API: the user of this sub.\n\n  /**\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\n   * @locus Server\n   * @memberOf Subscription\n   * @name  userId\n   * @instance\n   */\n  self.userId = session.userId;\n\n  // For now, the id filter is going to default to\n  // the to/from DDP methods on MongoID, to\n  // specifically deal with mongo/minimongo ObjectIds.\n\n  // Later, you will be able to make this be \"raw\"\n  // if you want to publish a collection that you know\n  // just has strings for keys and no funny business, to\n  // a DDP consumer that isn't minimongo.\n\n  self._idFilter = {\n    idStringify: MongoID.idStringify,\n    idParse: MongoID.idParse\n  };\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"subscriptions\", 1);\n};\nObject.assign(Subscription.prototype, {\n  _runHandler: function () {\n    // XXX should we unblock() here? Either before running the publish\n    // function, or before running _publishCursor.\n    //\n    // Right now, each publish function blocks all future publishes and\n    // methods waiting on data from Mongo (or whatever else the function\n    // blocks on). This probably slows page load in common cases.\n\n    if (!this.unblock) {\n      this.unblock = () => {};\n    }\n    const self = this;\n    let resultOrThenable = null;\n    try {\n      resultOrThenable = DDP._CurrentPublicationInvocation.withValue(self, () => maybeAuditArgumentChecks(self._handler, self, EJSON.clone(self._params),\n      // It's OK that this would look weird for universal subscriptions,\n      // because they have no arguments so there can never be an\n      // audit-argument-checks failure.\n      \"publisher '\" + self._name + \"'\"));\n    } catch (e) {\n      self.error(e);\n      return;\n    }\n\n    // Did the handler call this.error or this.stop?\n    if (self._isDeactivated()) return;\n\n    // Both conventional and async publish handler functions are supported.\n    // If an object is returned with a then() function, it is either a promise\n    // or thenable and will be resolved asynchronously.\n    const isThenable = resultOrThenable && typeof resultOrThenable.then === 'function';\n    if (isThenable) {\n      Promise.resolve(resultOrThenable).then(function () {\n        return self._publishHandlerResult.bind(self)(...arguments);\n      }, e => self.error(e));\n    } else {\n      self._publishHandlerResult(resultOrThenable);\n    }\n  },\n  _publishHandlerResult: function (res) {\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke\n    // this.added/changed/ready/etc, the user can just return a collection\n    // cursor or array of cursors from the publish function; we call their\n    // _publishCursor method which starts observing the cursor and publishes the\n    // results. Note that _publishCursor does NOT call ready().\n    //\n    // XXX This uses an undocumented interface which only the Mongo cursor\n    // interface publishes. Should we make this interface public and encourage\n    // users to implement it themselves? Arguably, it's unnecessary; users can\n    // already write their own functions like\n    //   var publishMyReactiveThingy = function (name, handler) {\n    //     Meteor.publish(name, function () {\n    //       var reactiveThingy = handler();\n    //       reactiveThingy.publishMe();\n    //     });\n    //   };\n\n    var self = this;\n    var isCursor = function (c) {\n      return c && c._publishCursor;\n    };\n    if (isCursor(res)) {\n      try {\n        res._publishCursor(self);\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      // _publishCursor only returns after the initial added callbacks have run.\n      // mark subscription as ready.\n      self.ready();\n    } else if (_.isArray(res)) {\n      // Check all the elements are cursors\n      if (!_.all(res, isCursor)) {\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));\n        return;\n      }\n      // Find duplicate collection names\n      // XXX we should support overlapping cursors, but that would require the\n      // merge box to allow overlap within a subscription\n      var collectionNames = {};\n      for (var i = 0; i < res.length; ++i) {\n        var collectionName = res[i]._getCollectionName();\n        if (_.has(collectionNames, collectionName)) {\n          self.error(new Error(\"Publish function returned multiple cursors for collection \" + collectionName));\n          return;\n        }\n        collectionNames[collectionName] = true;\n      }\n      ;\n      try {\n        _.each(res, function (cur) {\n          cur._publishCursor(self);\n        });\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      self.ready();\n    } else if (res) {\n      // Truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      self.error(new Error(\"Publish function can only return a Cursor or \" + \"an array of Cursors\"));\n    }\n  },\n  // This calls all stop callbacks and prevents the handler from updating any\n  // SessionCollectionViews further. It's used when the user unsubscribes or\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\n  // removed messages for the published objects; if that is necessary, call\n  // _removeAllDocuments first.\n  _deactivate: function () {\n    var self = this;\n    if (self._deactivated) return;\n    self._deactivated = true;\n    self._callStopCallbacks();\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\"livedata\", \"subscriptions\", -1);\n  },\n  _callStopCallbacks: function () {\n    var self = this;\n    // Tell listeners, so they can clean up\n    var callbacks = self._stopCallbacks;\n    self._stopCallbacks = [];\n    _.each(callbacks, function (callback) {\n      callback();\n    });\n  },\n  // Send remove messages for every document.\n  _removeAllDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._documents.forEach(function (collectionDocs, collectionName) {\n        collectionDocs.forEach(function (strId) {\n          self.removed(collectionName, self._idFilter.idParse(strId));\n        });\n      });\n    });\n  },\n  // Returns a new Subscription for the same session with the same\n  // initial creation parameters. This isn't a clone: it doesn't have\n  // the same _documents cache, stopped state or callbacks; may have a\n  // different _subscriptionHandle, and gets its userId from the\n  // session, not from this object.\n  _recreate: function () {\n    var self = this;\n    return new Subscription(self._session, self._handler, self._subscriptionId, self._params, self._name);\n  },\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server\n   * @param {Error} error The error to pass to the client.\n   * @instance\n   * @memberOf Subscription\n   */\n  error: function (error) {\n    var self = this;\n    if (self._isDeactivated()) return;\n    self._session._stopSubscription(self._subscriptionId, error);\n  },\n  // Note that while our DDP client will notice that you've called stop() on the\n  // server (and clean up its _subscriptions table) we don't actually provide a\n  // mechanism for an app to notice this (the subscribe onError callback only\n  // triggers if there is an error).\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server\n   * @instance\n   * @memberOf Subscription\n   */\n  stop: function () {\n    var self = this;\n    if (self._isDeactivated()) return;\n    self._session._stopSubscription(self._subscriptionId);\n  },\n  /**\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {Function} func The callback function\n   */\n  onStop: function (callback) {\n    var self = this;\n    callback = Meteor.bindEnvironment(callback, 'onStop callback', self);\n    if (self._isDeactivated()) callback();else self._stopCallbacks.push(callback);\n  },\n  // This returns true if the sub has been deactivated, *OR* if the session was\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\n  // happened yet.\n  _isDeactivated: function () {\n    var self = this;\n    return self._deactivated || self._session.inQueue === null;\n  },\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the new document.\n   * @param {String} id The new document's ID.\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\n   */\n  added(collectionName, id, fields) {\n    if (this._isDeactivated()) return;\n    id = this._idFilter.idStringify(id);\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      let ids = this._documents.get(collectionName);\n      if (ids == null) {\n        ids = new Set();\n        this._documents.set(collectionName, ids);\n      }\n      ids.add(id);\n    }\n    this._session.added(this._subscriptionHandle, collectionName, id, fields);\n  },\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the changed document.\n   * @param {String} id The changed document's ID.\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */\n  changed(collectionName, id, fields) {\n    if (this._isDeactivated()) return;\n    id = this._idFilter.idStringify(id);\n    this._session.changed(this._subscriptionHandle, collectionName, id, fields);\n  },\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that the document has been removed from.\n   * @param {String} id The ID of the document that has been removed.\n   */\n  removed(collectionName, id) {\n    if (this._isDeactivated()) return;\n    id = this._idFilter.idStringify(id);\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      // We don't bother to delete sets of things in a collection if the\n      // collection is empty.  It could break _removeAllDocuments.\n      this._documents.get(collectionName).delete(id);\n    }\n    this._session.removed(this._subscriptionHandle, collectionName, id);\n  },\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   */\n  ready: function () {\n    var self = this;\n    if (self._isDeactivated()) return;\n    if (!self._subscriptionId) return; // Unnecessary but ignored for universal sub\n    if (!self._ready) {\n      self._session.sendReady([self._subscriptionId]);\n      self._ready = true;\n    }\n  }\n});\n\n/******************************************************************************/\n/* Server                                                                     */\n/******************************************************************************/\n\nServer = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var self = this;\n\n  // The default heartbeat interval is 30 seconds on the server and 35\n  // seconds on the client.  Since the client doesn't need to send a\n  // ping as long as it is receiving pings, this means that pings\n  // normally go from the server to the client.\n  //\n  // Note: Troposphere depends on the ability to mutate\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n  self.options = _objectSpread({\n    heartbeatInterval: 15000,\n    heartbeatTimeout: 15000,\n    // For testing, allow responding to pings to be disabled.\n    respondToPings: true,\n    defaultPublicationStrategy: publicationStrategies.SERVER_MERGE\n  }, options);\n\n  // Map of callbacks to call when a new connection comes in to the\n  // server and completes DDP version negotiation. Use an object instead\n  // of an array so we can safely remove one from the list while\n  // iterating over it.\n  self.onConnectionHook = new Hook({\n    debugPrintExceptions: \"onConnection callback\"\n  });\n\n  // Map of callbacks to call when a new message comes in.\n  self.onMessageHook = new Hook({\n    debugPrintExceptions: \"onMessage callback\"\n  });\n  self.publish_handlers = {};\n  self.universal_publish_handlers = [];\n  self.method_handlers = {};\n  self._publicationStrategies = {};\n  self.sessions = new Map(); // map from id to session\n\n  self.stream_server = new StreamServer();\n  self.stream_server.register(function (socket) {\n    // socket implements the SockJSConnection interface\n    socket._meteorSession = null;\n    var sendError = function (reason, offendingMessage) {\n      var msg = {\n        msg: 'error',\n        reason: reason\n      };\n      if (offendingMessage) msg.offendingMessage = offendingMessage;\n      socket.send(DDPCommon.stringifyDDP(msg));\n    };\n    socket.on('data', function (raw_msg) {\n      if (Meteor._printReceivedDDP) {\n        Meteor._debug(\"Received DDP\", raw_msg);\n      }\n      try {\n        try {\n          var msg = DDPCommon.parseDDP(raw_msg);\n        } catch (err) {\n          sendError('Parse error');\n          return;\n        }\n        if (msg === null || !msg.msg) {\n          sendError('Bad request', msg);\n          return;\n        }\n        if (msg.msg === 'connect') {\n          if (socket._meteorSession) {\n            sendError(\"Already connected\", msg);\n            return;\n          }\n          Fiber(function () {\n            self._handleConnect(socket, msg);\n          }).run();\n          return;\n        }\n        if (!socket._meteorSession) {\n          sendError('Must connect first', msg);\n          return;\n        }\n        socket._meteorSession.processMessage(msg);\n      } catch (e) {\n        // XXX print stack nicely\n        Meteor._debug(\"Internal exception while processing message\", msg, e);\n      }\n    });\n    socket.on('close', function () {\n      if (socket._meteorSession) {\n        Fiber(function () {\n          socket._meteorSession.close();\n        }).run();\n      }\n    });\n  });\n};\nObject.assign(Server.prototype, {\n  /**\n   * @summary Register a callback to be called when a new DDP connection is made to the server.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP connection is established.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onConnection: function (fn) {\n    var self = this;\n    return self.onConnectionHook.register(fn);\n  },\n  /**\n   * @summary Set publication strategy for the given collection. Publications strategies are available from `DDPServer.publicationStrategies`. You call this method from `Meteor.server`, like `Meteor.server.setPublicationStrategy()`\n   * @locus Server\n   * @alias setPublicationStrategy\n   * @param collectionName {String}\n   * @param strategy {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   */\n  setPublicationStrategy(collectionName, strategy) {\n    if (!Object.values(publicationStrategies).includes(strategy)) {\n      throw new Error(\"Invalid merge strategy: \".concat(strategy, \" \\n        for collection \").concat(collectionName));\n    }\n    this._publicationStrategies[collectionName] = strategy;\n  },\n  /**\n   * @summary Gets the publication strategy for the requested collection. You call this method from `Meteor.server`, like `Meteor.server.getPublicationStrategy()`\n   * @locus Server\n   * @alias getPublicationStrategy\n   * @param collectionName {String}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   * @return {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   */\n  getPublicationStrategy(collectionName) {\n    return this._publicationStrategies[collectionName] || this.options.defaultPublicationStrategy;\n  },\n  /**\n   * @summary Register a callback to be called when a new DDP message is received.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP message is received.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onMessage: function (fn) {\n    var self = this;\n    return self.onMessageHook.register(fn);\n  },\n  _handleConnect: function (socket, msg) {\n    var self = this;\n\n    // The connect message must specify a version and an array of supported\n    // versions, and it must claim to support what it is proposing.\n    if (!(typeof msg.version === 'string' && _.isArray(msg.support) && _.all(msg.support, _.isString) && _.contains(msg.support, msg.version))) {\n      socket.send(DDPCommon.stringifyDDP({\n        msg: 'failed',\n        version: DDPCommon.SUPPORTED_DDP_VERSIONS[0]\n      }));\n      socket.close();\n      return;\n    }\n\n    // In the future, handle session resumption: something like:\n    //  socket._meteorSession = self.sessions[msg.session]\n    var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);\n    if (msg.version !== version) {\n      // The best version to use (according to the client's stated preferences)\n      // is not the one the client is trying to use. Inform them about the best\n      // version to use.\n      socket.send(DDPCommon.stringifyDDP({\n        msg: 'failed',\n        version: version\n      }));\n      socket.close();\n      return;\n    }\n\n    // Yay, version matches! Create a new session.\n    // Note: Troposphere depends on the ability to mutate\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n    socket._meteorSession = new Session(self, version, socket, self.options);\n    self.sessions.set(socket._meteorSession.id, socket._meteorSession);\n    self.onConnectionHook.each(function (callback) {\n      if (socket._meteorSession) callback(socket._meteorSession.connectionHandle);\n      return true;\n    });\n  },\n  /**\n   * Register a publish handler function.\n   *\n   * @param name {String} identifier for query\n   * @param handler {Function} publish handler\n   * @param options {Object}\n   *\n   * Server will call handler function on each new subscription,\n   * either when receiving DDP sub message for a named subscription, or on\n   * DDP connect for a universal subscription.\n   *\n   * If name is null, this will be a subscription that is\n   * automatically established and permanently on for all connected\n   * client, instead of a subscription that can be turned on and off\n   * with subscribe().\n   *\n   * options to contain:\n   *  - (mostly internal) is_auto: true if generated automatically\n   *    from an autopublish hook. this is for cosmetic purposes only\n   *    (it lets us determine whether to print a warning suggesting\n   *    that you turn off autopublish).\n   */\n\n  /**\n   * @summary Publish a record set.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @locus Server\n   * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */\n  publish: function (name, handler, options) {\n    var self = this;\n    if (!_.isObject(name)) {\n      options = options || {};\n      if (name && name in self.publish_handlers) {\n        Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\n        return;\n      }\n      if (Package.autopublish && !options.is_auto) {\n        // They have autopublish on, yet they're trying to manually\n        // pick stuff to publish. They probably should turn off\n        // autopublish. (This check isn't perfect -- if you create a\n        // publish before you turn on autopublish, it won't catch\n        // it, but this will definitely handle the simple case where\n        // you've added the autopublish package to your app, and are\n        // calling publish from your app code).\n        if (!self.warned_about_autopublish) {\n          self.warned_about_autopublish = true;\n          Meteor._debug(\"** You've set up some data subscriptions with Meteor.publish(), but\\n\" + \"** you still have autopublish turned on. Because autopublish is still\\n\" + \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" + \"** will still be sent to all clients.\\n\" + \"**\\n\" + \"** Turn off autopublish by removing the autopublish package:\\n\" + \"**\\n\" + \"**   $ meteor remove autopublish\\n\" + \"**\\n\" + \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" + \"** for each collection that you want clients to see.\\n\");\n        }\n      }\n      if (name) self.publish_handlers[name] = handler;else {\n        self.universal_publish_handlers.push(handler);\n        // Spin up the new publisher on any existing session too. Run each\n        // session's subscription in a new Fiber, so that there's no change for\n        // self.sessions to change while we're running this loop.\n        self.sessions.forEach(function (session) {\n          if (!session._dontStartNewUniversalSubs) {\n            Fiber(function () {\n              session._startSubscription(handler);\n            }).run();\n          }\n        });\n      }\n    } else {\n      _.each(name, function (value, key) {\n        self.publish(key, value, {});\n      });\n    }\n  },\n  _removeSession: function (session) {\n    var self = this;\n    self.sessions.delete(session.id);\n  },\n  /**\n   * @summary Defines functions that can be invoked over the network by clients.\n   * @locus Anywhere\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  methods: function (methods) {\n    var self = this;\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function') throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self.method_handlers[name]) throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self.method_handlers[name] = func;\n    });\n  },\n  call: function (name) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (args.length && typeof args[args.length - 1] === \"function\") {\n      // If it's a function, the last argument is the result callback, not\n      // a parameter to the remote method.\n      var callback = args.pop();\n    }\n    return this.apply(name, args, callback);\n  },\n  // A version of the call method that always returns a Promise.\n  callAsync: function (name) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return this.applyAsync(name, args);\n  },\n  apply: function (name, args, options, callback) {\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else {\n      options = options || {};\n    }\n    const promise = this.applyAsync(name, args, options);\n\n    // Return the result in whichever way the caller asked for it. Note that we\n    // do NOT block on the write fence in an analogous way to how the client\n    // blocks on the relevant data being visible, so you are NOT guaranteed that\n    // cursor observe callbacks have fired when your callback is invoked. (We\n    // can change this if there's a real use case).\n    if (callback) {\n      promise.then(result => callback(undefined, result), exception => callback(exception));\n    } else {\n      return promise.await();\n    }\n  },\n  // @param options {Optional Object}\n  applyAsync: function (name, args, options) {\n    // Run the handler\n    var handler = this.method_handlers[name];\n    if (!handler) {\n      return Promise.reject(new Meteor.Error(404, \"Method '\".concat(name, \"' not found\")));\n    }\n\n    // If this is a method call from within another method or publish function,\n    // get the user state from the outer method or publish function, otherwise\n    // don't allow setUserId to be called\n    var userId = null;\n    var setUserId = function () {\n      throw new Error(\"Can't call setUserId on a server initiated method call\");\n    };\n    var connection = null;\n    var currentMethodInvocation = DDP._CurrentMethodInvocation.get();\n    var currentPublicationInvocation = DDP._CurrentPublicationInvocation.get();\n    var randomSeed = null;\n    if (currentMethodInvocation) {\n      userId = currentMethodInvocation.userId;\n      setUserId = function (userId) {\n        currentMethodInvocation.setUserId(userId);\n      };\n      connection = currentMethodInvocation.connection;\n      randomSeed = DDPCommon.makeRpcSeed(currentMethodInvocation, name);\n    } else if (currentPublicationInvocation) {\n      userId = currentPublicationInvocation.userId;\n      setUserId = function (userId) {\n        currentPublicationInvocation._session._setUserId(userId);\n      };\n      connection = currentPublicationInvocation.connection;\n    }\n    var invocation = new DDPCommon.MethodInvocation({\n      isSimulation: false,\n      userId,\n      setUserId,\n      connection,\n      randomSeed\n    });\n    return new Promise(resolve => resolve(DDP._CurrentMethodInvocation.withValue(invocation, () => maybeAuditArgumentChecks(handler, invocation, EJSON.clone(args), \"internal call to '\" + name + \"'\")))).then(EJSON.clone);\n  },\n  _urlForSession: function (sessionId) {\n    var self = this;\n    var session = self.sessions.get(sessionId);\n    if (session) return session._socketUrl;else return null;\n  }\n});\nvar calculateVersion = function (clientSupportedVersions, serverSupportedVersions) {\n  var correctVersion = _.find(clientSupportedVersions, function (version) {\n    return _.contains(serverSupportedVersions, version);\n  });\n  if (!correctVersion) {\n    correctVersion = serverSupportedVersions[0];\n  }\n  return correctVersion;\n};\nDDPServer._calculateVersion = calculateVersion;\n\n// \"blind\" exceptions other than those that were deliberately thrown to signal\n// errors to the client\nvar wrapInternalException = function (exception, context) {\n  if (!exception) return exception;\n\n  // To allow packages to throw errors intended for the client but not have to\n  // depend on the Meteor.Error class, `isClientSafe` can be set to true on any\n  // error before it is thrown.\n  if (exception.isClientSafe) {\n    if (!(exception instanceof Meteor.Error)) {\n      const originalMessage = exception.message;\n      exception = new Meteor.Error(exception.error, exception.reason, exception.details);\n      exception.message = originalMessage;\n    }\n    return exception;\n  }\n\n  // Tests can set the '_expectedByTest' flag on an exception so it won't go to\n  // the server log.\n  if (!exception._expectedByTest) {\n    Meteor._debug(\"Exception \" + context, exception.stack);\n    if (exception.sanitizedError) {\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError);\n      Meteor._debug();\n    }\n  }\n\n  // Did the error contain more details that could have been useful if caught in\n  // server code (or if thrown from non-client-originated code), but also\n  // provided a \"sanitized\" version with more context than 500 Internal server\n  // error? Use that.\n  if (exception.sanitizedError) {\n    if (exception.sanitizedError.isClientSafe) return exception.sanitizedError;\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" + \"does not have isClientSafe property set; ignoring\");\n  }\n  return new Meteor.Error(500, \"Internal server error\");\n};\n\n// Audit argument checks, if the audit-argument-checks package exists (it is a\n// weak dependency of this package).\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\n  args = args || [];\n  if (Package['audit-argument-checks']) {\n    return Match._failIfArgumentsAreNotAllChecked(f, context, args, description);\n  }\n  return f.apply(context, args);\n};","map":{"version":3,"names":["_objectSpread","module","link","default","v","DDPServer","Fiber","Npm","require","publicationStrategies","SERVER_MERGE","useCollectionView","doAccountingForCollection","NO_MERGE_NO_HISTORY","NO_MERGE","SessionDocumentView","self","existsIn","Set","dataByKey","Map","_SessionDocumentView","_","extend","prototype","getFields","ret","forEach","precedenceList","key","value","clearField","subscriptionHandle","changeCollector","get","removedValue","undefined","i","length","precedence","splice","delete","EJSON","equals","changeField","isAdd","clone","has","set","elt","find","push","SessionCollectionView","collectionName","sessionCallbacks","documents","callbacks","_SessionCollectionView","Object","assign","isEmpty","size","diff","previous","DiffSequence","diffMaps","both","bind","diffDocument","rightOnly","id","nowDV","added","leftOnly","prevDV","removed","fields","diffObjects","prev","now","changed","docView","add","each","changedResult","Error","err","Session","server","version","socket","options","Random","initialized","inQueue","Meteor","_DoubleEndedQueue","blocked","workerRunning","cachedUnblock","_namedSubs","_universalSubs","userId","collectionViews","_isSending","_dontStartNewUniversalSubs","_pendingReady","_closeCallbacks","_socketUrl","url","_respondToPings","respondToPings","connectionHandle","close","onClose","fn","cb","bindEnvironment","defer","clientAddress","_clientAddress","httpHeaders","headers","send","msg","session","startUniversalSubs","run","heartbeatInterval","setWebsocketTimeout","heartbeat","DDPCommon","Heartbeat","heartbeatTimeout","onTimeout","sendPing","start","Package","Facts","incrementServerFact","sendReady","subscriptionIds","subs","subscriptionId","_canSend","getPublicationStrategy","sendAdded","collection","sendChanged","sendRemoved","getSendCallbacks","getCollectionView","view","handlers","universal_publish_handlers","handler","_startSubscription","stop","_meteorSession","_deactivateAllSubscriptions","callback","_removeSession","_printSentDDP","_debug","stringifyDDP","sendError","reason","offendingMessage","processMessage","msg_in","messageReceived","processNext","shift","unblock","onMessageHook","protocol_handlers","call","sub","name","params","Array","publish_handlers","error","DDPRateLimiter","rateLimiterInput","type","connectionId","_increment","rateLimitResult","_check","allowed","getErrorMessage","timeToReset","unsub","_stopSubscription","method","randomSeed","fence","_WriteFence","onAllCommitted","retire","methods","method_handlers","arm","setUserId","_setUserId","invocation","MethodInvocation","isSimulation","connection","promise","Promise","resolve","reject","getCurrentMethodInvocationResult","currentContext","DDP","_CurrentMethodInvocation","_setNewContextAndGetCurrent","result","resultOrThenable","maybeAuditArgumentChecks","isThenable","then","await","_set","_CurrentWriteFence","withValue","finish","payload","exception","wrapInternalException","_eachSub","f","_diffCollectionViews","beforeCVs","leftValue","rightValue","doc","_deactivate","oldNamedSubs","newSub","_recreate","_runHandler","_noYieldsAllowed","subId","Subscription","unblockHander","subName","maybeSub","_name","_removeAllDocuments","response","httpForwardedCount","parseInt","process","env","remoteAddress","forwardedFor","isString","trim","split","_session","_handler","_subscriptionId","_params","_subscriptionHandle","_deactivated","_stopCallbacks","_documents","_ready","_idFilter","idStringify","MongoID","idParse","_CurrentPublicationInvocation","e","_isDeactivated","_publishHandlerResult","res","isCursor","c","_publishCursor","ready","isArray","all","collectionNames","_getCollectionName","cur","_callStopCallbacks","collectionDocs","strId","onStop","ids","Server","defaultPublicationStrategy","onConnectionHook","Hook","debugPrintExceptions","_publicationStrategies","sessions","stream_server","StreamServer","register","on","raw_msg","_printReceivedDDP","parseDDP","_handleConnect","onConnection","setPublicationStrategy","strategy","values","includes","onMessage","support","contains","SUPPORTED_DDP_VERSIONS","calculateVersion","publish","isObject","autopublish","is_auto","warned_about_autopublish","func","args","pop","apply","callAsync","applyAsync","currentMethodInvocation","currentPublicationInvocation","makeRpcSeed","_urlForSession","sessionId","clientSupportedVersions","serverSupportedVersions","correctVersion","_calculateVersion","context","isClientSafe","originalMessage","message","details","_expectedByTest","stack","sanitizedError","description","Match","_failIfArgumentsAreNotAllChecked"],"sources":["packages/ddp-server/livedata_server.js"],"sourcesContent":["DDPServer = {};\n\nvar Fiber = Npm.require('fibers');\n\n// Publication strategies define how we handle data from published cursors at the collection level\n// This allows someone to:\n// - Choose a trade-off between client-server bandwidth and server memory usage\n// - Implement special (non-mongo) collections like volatile message queues\nconst publicationStrategies = {\n  // SERVER_MERGE is the default strategy.\n  // When using this strategy, the server maintains a copy of all data a connection is subscribed to.\n  // This allows us to only send deltas over multiple publications.\n  SERVER_MERGE: {\n    useCollectionView: true,\n    doAccountingForCollection: true,\n  },\n  // The NO_MERGE_NO_HISTORY strategy results in the server sending all publication data\n  // directly to the client. It does not remember what it has previously sent\n  // to it will not trigger removed messages when a subscription is stopped.\n  // This should only be chosen for special use cases like send-and-forget queues.\n  NO_MERGE_NO_HISTORY: {\n    useCollectionView: false,\n    doAccountingForCollection: false,\n  },\n  // NO_MERGE is similar to NO_MERGE_NO_HISTORY but the server will remember the IDs it has\n  // sent to the client so it can remove them when a subscription is stopped.\n  // This strategy can be used when a collection is only used in a single publication.\n  NO_MERGE: {\n    useCollectionView: false,\n    doAccountingForCollection: true,\n  }\n};\n\nDDPServer.publicationStrategies = publicationStrategies;\n\n// This file contains classes:\n// * Session - The server's connection to a single DDP client\n// * Subscription - A single subscription for a single client\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\n//\n// Session and Subscription are file scope. For now, until we freeze\n// the interface, Server is package scope (in the future it should be\n// exported).\n\n// Represents a single document in a SessionCollectionView\nvar SessionDocumentView = function () {\n  var self = this;\n  self.existsIn = new Set(); // set of subscriptionHandle\n  self.dataByKey = new Map(); // key-> [ {subscriptionHandle, value} by precedence]\n};\n\nDDPServer._SessionDocumentView = SessionDocumentView;\n\n\n_.extend(SessionDocumentView.prototype, {\n\n  getFields: function () {\n    var self = this;\n    var ret = {};\n    self.dataByKey.forEach(function (precedenceList, key) {\n      ret[key] = precedenceList[0].value;\n    });\n    return ret;\n  },\n\n  clearField: function (subscriptionHandle, key, changeCollector) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n    var precedenceList = self.dataByKey.get(key);\n\n    // It's okay to clear fields that didn't exist. No need to throw\n    // an error.\n    if (!precedenceList)\n      return;\n\n    var removedValue = undefined;\n    for (var i = 0; i < precedenceList.length; i++) {\n      var precedence = precedenceList[i];\n      if (precedence.subscriptionHandle === subscriptionHandle) {\n        // The view's value can only change if this subscription is the one that\n        // used to have precedence.\n        if (i === 0)\n          removedValue = precedence.value;\n        precedenceList.splice(i, 1);\n        break;\n      }\n    }\n    if (precedenceList.length === 0) {\n      self.dataByKey.delete(key);\n      changeCollector[key] = undefined;\n    } else if (removedValue !== undefined &&\n               !EJSON.equals(removedValue, precedenceList[0].value)) {\n      changeCollector[key] = precedenceList[0].value;\n    }\n  },\n\n  changeField: function (subscriptionHandle, key, value,\n                         changeCollector, isAdd) {\n    var self = this;\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\")\n      return;\n\n    // Don't share state with the data passed in by the user.\n    value = EJSON.clone(value);\n\n    if (!self.dataByKey.has(key)) {\n      self.dataByKey.set(key, [{subscriptionHandle: subscriptionHandle,\n                                value: value}]);\n      changeCollector[key] = value;\n      return;\n    }\n    var precedenceList = self.dataByKey.get(key);\n    var elt;\n    if (!isAdd) {\n      elt = precedenceList.find(function (precedence) {\n          return precedence.subscriptionHandle === subscriptionHandle;\n      });\n    }\n\n    if (elt) {\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n        // this subscription is changing the value of this field.\n        changeCollector[key] = value;\n      }\n      elt.value = value;\n    } else {\n      // this subscription is newly caring about this field\n      precedenceList.push({subscriptionHandle: subscriptionHandle, value: value});\n    }\n\n  }\n});\n\n/**\n * Represents a client's view of a single collection\n * @param {String} collectionName Name of the collection it represents\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed\n * @class SessionCollectionView\n */\nvar SessionCollectionView = function (collectionName, sessionCallbacks) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.documents = new Map();\n  self.callbacks = sessionCallbacks;\n};\n\nDDPServer._SessionCollectionView = SessionCollectionView;\n\n\nObject.assign(SessionCollectionView.prototype, {\n\n  isEmpty: function () {\n    var self = this;\n    return self.documents.size === 0;\n  },\n\n  diff: function (previous) {\n    var self = this;\n    DiffSequence.diffMaps(previous.documents, self.documents, {\n      both: _.bind(self.diffDocument, self),\n\n      rightOnly: function (id, nowDV) {\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());\n      },\n\n      leftOnly: function (id, prevDV) {\n        self.callbacks.removed(self.collectionName, id);\n      }\n    });\n  },\n\n  diffDocument: function (id, prevDV, nowDV) {\n    var self = this;\n    var fields = {};\n    DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {\n      both: function (key, prev, now) {\n        if (!EJSON.equals(prev, now))\n          fields[key] = now;\n      },\n      rightOnly: function (key, now) {\n        fields[key] = now;\n      },\n      leftOnly: function(key, prev) {\n        fields[key] = undefined;\n      }\n    });\n    self.callbacks.changed(self.collectionName, id, fields);\n  },\n\n  added: function (subscriptionHandle, id, fields) {\n    var self = this;\n    var docView = self.documents.get(id);\n    var added = false;\n    if (!docView) {\n      added = true;\n      docView = new SessionDocumentView();\n      self.documents.set(id, docView);\n    }\n    docView.existsIn.add(subscriptionHandle);\n    var changeCollector = {};\n    _.each(fields, function (value, key) {\n      docView.changeField(\n        subscriptionHandle, key, value, changeCollector, true);\n    });\n    if (added)\n      self.callbacks.added(self.collectionName, id, changeCollector);\n    else\n      self.callbacks.changed(self.collectionName, id, changeCollector);\n  },\n\n  changed: function (subscriptionHandle, id, changed) {\n    var self = this;\n    var changedResult = {};\n    var docView = self.documents.get(id);\n    if (!docView)\n      throw new Error(\"Could not find element with id \" + id + \" to change\");\n    _.each(changed, function (value, key) {\n      if (value === undefined)\n        docView.clearField(subscriptionHandle, key, changedResult);\n      else\n        docView.changeField(subscriptionHandle, key, value, changedResult);\n    });\n    self.callbacks.changed(self.collectionName, id, changedResult);\n  },\n\n  removed: function (subscriptionHandle, id) {\n    var self = this;\n    var docView = self.documents.get(id);\n    if (!docView) {\n      var err = new Error(\"Removed nonexistent document \" + id);\n      throw err;\n    }\n    docView.existsIn.delete(subscriptionHandle);\n    if (docView.existsIn.size === 0) {\n      // it is gone from everyone\n      self.callbacks.removed(self.collectionName, id);\n      self.documents.delete(id);\n    } else {\n      var changed = {};\n      // remove this subscription from every precedence list\n      // and record the changes\n      docView.dataByKey.forEach(function (precedenceList, key) {\n        docView.clearField(subscriptionHandle, key, changed);\n      });\n\n      self.callbacks.changed(self.collectionName, id, changed);\n    }\n  }\n});\n\n/******************************************************************************/\n/* Session                                                                    */\n/******************************************************************************/\n\nvar Session = function (server, version, socket, options) {\n  var self = this;\n  self.id = Random.id();\n\n  self.server = server;\n  self.version = version;\n\n  self.initialized = false;\n  self.socket = socket;\n\n  // Set to null when the session is destroyed. Multiple places below\n  // use this to determine if the session is alive or not.\n  self.inQueue = new Meteor._DoubleEndedQueue();\n\n  self.blocked = false;\n  self.workerRunning = false;\n\n  self.cachedUnblock = null;\n\n  // Sub objects for active subscriptions\n  self._namedSubs = new Map();\n  self._universalSubs = [];\n\n  self.userId = null;\n\n  self.collectionViews = new Map();\n\n  // Set this to false to not send messages when collectionViews are\n  // modified. This is done when rerunning subs in _setUserId and those messages\n  // are calculated via a diff instead.\n  self._isSending = true;\n\n  // If this is true, don't start a newly-created universal publisher on this\n  // session. The session will take care of starting it when appropriate.\n  self._dontStartNewUniversalSubs = false;\n\n  // When we are rerunning subscriptions, any ready messages\n  // we want to buffer up for when we are done rerunning subscriptions\n  self._pendingReady = [];\n\n  // List of callbacks to call when this connection is closed.\n  self._closeCallbacks = [];\n\n\n  // XXX HACK: If a sockjs connection, save off the URL. This is\n  // temporary and will go away in the near future.\n  self._socketUrl = socket.url;\n\n  // Allow tests to disable responding to pings.\n  self._respondToPings = options.respondToPings;\n\n  // This object is the public interface to the session. In the public\n  // API, it is called the `connection` object.  Internally we call it\n  // a `connectionHandle` to avoid ambiguity.\n  self.connectionHandle = {\n    id: self.id,\n    close: function () {\n      self.close();\n    },\n    onClose: function (fn) {\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\n      if (self.inQueue) {\n        self._closeCallbacks.push(cb);\n      } else {\n        // if we're already closed, call the callback.\n        Meteor.defer(cb);\n      }\n    },\n    clientAddress: self._clientAddress(),\n    httpHeaders: self.socket.headers\n  };\n\n  self.send({ msg: 'connected', session: self.id });\n\n  // On initial connect, spin up all the universal publishers.\n  Fiber(function () {\n    self.startUniversalSubs();\n  }).run();\n\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n    // We no longer need the low level timeout because we have heartbeats.\n    socket.setWebsocketTimeout(0);\n\n    self.heartbeat = new DDPCommon.Heartbeat({\n      heartbeatInterval: options.heartbeatInterval,\n      heartbeatTimeout: options.heartbeatTimeout,\n      onTimeout: function () {\n        self.close();\n      },\n      sendPing: function () {\n        self.send({msg: 'ping'});\n      }\n    });\n    self.heartbeat.start();\n  }\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"livedata\", \"sessions\", 1);\n};\n\nObject.assign(Session.prototype, {\n\n  sendReady: function (subscriptionIds) {\n    var self = this;\n    if (self._isSending)\n      self.send({msg: \"ready\", subs: subscriptionIds});\n    else {\n      _.each(subscriptionIds, function (subscriptionId) {\n        self._pendingReady.push(subscriptionId);\n      });\n    }\n  },\n\n  _canSend(collectionName) {\n    return this._isSending || !this.server.getPublicationStrategy(collectionName).useCollectionView;\n  },\n\n\n  sendAdded(collectionName, id, fields) {\n    if (this._canSend(collectionName))\n      this.send({msg: \"added\", collection: collectionName, id, fields});\n  },\n\n  sendChanged(collectionName, id, fields) {\n    if (_.isEmpty(fields))\n      return;\n\n    if (this._canSend(collectionName)) {\n      this.send({\n        msg: \"changed\",\n        collection: collectionName,\n        id,\n        fields\n      });\n    }\n  },\n\n  sendRemoved(collectionName, id) {\n    if (this._canSend(collectionName))\n      this.send({msg: \"removed\", collection: collectionName, id});\n  },\n\n  getSendCallbacks: function () {\n    var self = this;\n    return {\n      added: _.bind(self.sendAdded, self),\n      changed: _.bind(self.sendChanged, self),\n      removed: _.bind(self.sendRemoved, self)\n    };\n  },\n\n  getCollectionView: function (collectionName) {\n    var self = this;\n    var ret = self.collectionViews.get(collectionName);\n    if (!ret) {\n      ret = new SessionCollectionView(collectionName,\n                                        self.getSendCallbacks());\n      self.collectionViews.set(collectionName, ret);\n    }\n    return ret;\n  },\n\n  added(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.added(subscriptionHandle, id, fields);\n    } else {\n      this.sendAdded(collectionName, id, fields);\n    }\n  },\n\n  removed(subscriptionHandle, collectionName, id) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.removed(subscriptionHandle, id);\n      if (view.isEmpty()) {\n         this.collectionViews.delete(collectionName);\n      }\n    } else {\n      this.sendRemoved(collectionName, id);\n    }\n  },\n\n  changed(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.changed(subscriptionHandle, id, fields);\n    } else {\n      this.sendChanged(collectionName, id, fields);\n    }\n  },\n\n  startUniversalSubs: function () {\n    var self = this;\n    // Make a shallow copy of the set of universal handlers and start them. If\n    // additional universal publishers start while we're running them (due to\n    // yielding), they will run separately as part of Server.publish.\n    var handlers = _.clone(self.server.universal_publish_handlers);\n    _.each(handlers, function (handler) {\n      self._startSubscription(handler);\n    });\n  },\n\n  // Destroy this session and unregister it at the server.\n  close: function () {\n    var self = this;\n\n    // Destroy this session, even if it's not registered at the\n    // server. Stop all processing and tear everything down. If a socket\n    // was attached, close it.\n\n    // Already destroyed.\n    if (! self.inQueue)\n      return;\n\n    // Drop the merge box data immediately.\n    self.inQueue = null;\n    self.collectionViews = new Map();\n\n    if (self.heartbeat) {\n      self.heartbeat.stop();\n      self.heartbeat = null;\n    }\n\n    if (self.socket) {\n      self.socket.close();\n      self.socket._meteorSession = null;\n    }\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"livedata\", \"sessions\", -1);\n\n    Meteor.defer(function () {\n      // Stop callbacks can yield, so we defer this on close.\n      // sub._isDeactivated() detects that we set inQueue to null and\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\n      self._deactivateAllSubscriptions();\n\n      // Defer calling the close callbacks, so that the caller closing\n      // the session isn't waiting for all the callbacks to complete.\n      _.each(self._closeCallbacks, function (callback) {\n        callback();\n      });\n    });\n\n    // Unregister the session.\n    self.server._removeSession(self);\n  },\n\n  // Send a message (doing nothing if no socket is connected right now).\n  // It should be a JSON object (it will be stringified).\n  send: function (msg) {\n    var self = this;\n    if (self.socket) {\n      if (Meteor._printSentDDP)\n        Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));\n      self.socket.send(DDPCommon.stringifyDDP(msg));\n    }\n  },\n\n  // Send a connection error.\n  sendError: function (reason, offendingMessage) {\n    var self = this;\n    var msg = {msg: 'error', reason: reason};\n    if (offendingMessage)\n      msg.offendingMessage = offendingMessage;\n    self.send(msg);\n  },\n\n  // Process 'msg' as an incoming message. As a guard against\n  // race conditions during reconnection, ignore the message if\n  // 'socket' is not the currently connected socket.\n  //\n  // We run the messages from the client one at a time, in the order\n  // given by the client. The message handler is passed an idempotent\n  // function 'unblock' which it may call to allow other messages to\n  // begin running in parallel in another fiber (for example, a method\n  // that wants to yield). Otherwise, it is automatically unblocked\n  // when it returns.\n  //\n  // Actually, we don't have to 'totally order' the messages in this\n  // way, but it's the easiest thing that's correct. (unsub needs to\n  // be ordered against sub, methods need to be ordered against each\n  // other).\n  processMessage: function (msg_in) {\n    var self = this;\n    if (!self.inQueue) // we have been destroyed.\n      return;\n\n    // Respond to ping and pong messages immediately without queuing.\n    // If the negotiated DDP version is \"pre1\" which didn't support\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad\n    // request\" for the unknown messages.\n    //\n    // Fibers are needed because heartbeats use Meteor.setTimeout, which\n    // needs a Fiber. We could actually use regular setTimeout and avoid\n    // these new fibers, but it is easier to just make everything use\n    // Meteor.setTimeout and not think too hard.\n    //\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the client is still alive.\n    if (self.heartbeat) {\n      Fiber(function () {\n        self.heartbeat.messageReceived();\n      }).run();\n    }\n\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n      if (self._respondToPings)\n        self.send({msg: \"pong\", id: msg_in.id});\n      return;\n    }\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n      // Since everything is a pong, there is nothing to do\n      return;\n    }\n\n    self.inQueue.push(msg_in);\n    if (self.workerRunning)\n      return;\n    self.workerRunning = true;\n\n    var processNext = function () {\n      var msg = self.inQueue && self.inQueue.shift();\n      if (!msg) {\n        self.workerRunning = false;\n        return;\n      }\n\n      Fiber(function () {\n        var blocked = true;\n\n        var unblock = function () {\n          if (!blocked)\n            return; // idempotent\n          blocked = false;\n          processNext();\n        };\n\n        self.server.onMessageHook.each(function (callback) {\n          callback(msg, self);\n          return true;\n        });\n\n        if (_.has(self.protocol_handlers, msg.msg))\n          self.protocol_handlers[msg.msg].call(self, msg, unblock);\n        else\n          self.sendError('Bad request', msg);\n        unblock(); // in case the handler didn't already do it\n      }).run();\n    };\n\n    processNext();\n  },\n\n  protocol_handlers: {\n    sub: function (msg, unblock) {\n      var self = this;\n\n      // cacheUnblock temporarly, so we can capture it later\n      // we will use unblock in current eventLoop, so this is safe\n      self.cachedUnblock = unblock;\n\n      // reject malformed messages\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.name) !== \"string\" ||\n          (('params' in msg) && !(msg.params instanceof Array))) {\n        self.sendError(\"Malformed subscription\", msg);\n        return;\n      }\n\n      if (!self.server.publish_handlers[msg.name]) {\n        self.send({\n          msg: 'nosub', id: msg.id,\n          error: new Meteor.Error(404, `Subscription '${msg.name}' not found`)});\n        return;\n      }\n\n      if (self._namedSubs.has(msg.id))\n        // subs are idempotent, or rather, they are ignored if a sub\n        // with that id already exists. this is important during\n        // reconnect.\n        return;\n\n      // XXX It'd be much better if we had generic hooks where any package can\n      // hook into subscription handling, but in the mean while we special case\n      // ddp-rate-limiter package. This is also done for weak requirements to\n      // add the ddp-rate-limiter package in case we don't have Accounts. A\n      // user trying to use the ddp-rate-limiter must explicitly require it.\n      if (Package['ddp-rate-limiter']) {\n        var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n        var rateLimiterInput = {\n          userId: self.userId,\n          clientAddress: self.connectionHandle.clientAddress,\n          type: \"subscription\",\n          name: msg.name,\n          connectionId: self.id\n        };\n\n        DDPRateLimiter._increment(rateLimiterInput);\n        var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n        if (!rateLimitResult.allowed) {\n          self.send({\n            msg: 'nosub', id: msg.id,\n            error: new Meteor.Error(\n              'too-many-requests',\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset})\n          });\n          return;\n        }\n      }\n\n      var handler = self.server.publish_handlers[msg.name];\n\n      self._startSubscription(handler, msg.id, msg.params, msg.name);\n\n      // cleaning cached unblock\n      self.cachedUnblock = null;\n    },\n\n    unsub: function (msg) {\n      var self = this;\n\n      self._stopSubscription(msg.id);\n    },\n\n    method: function (msg, unblock) {\n      var self = this;\n\n      // Reject malformed messages.\n      // For now, we silently ignore unknown attributes,\n      // for forwards compatibility.\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.method) !== \"string\" ||\n          (('params' in msg) && !(msg.params instanceof Array)) ||\n          (('randomSeed' in msg) && (typeof msg.randomSeed !== \"string\"))) {\n        self.sendError(\"Malformed method invocation\", msg);\n        return;\n      }\n\n      var randomSeed = msg.randomSeed || null;\n\n      // Set up to mark the method as satisfied once all observers\n      // (and subscriptions) have reacted to any writes that were\n      // done.\n      var fence = new DDPServer._WriteFence;\n      fence.onAllCommitted(function () {\n        // Retire the fence so that future writes are allowed.\n        // This means that callbacks like timers are free to use\n        // the fence, and if they fire before it's armed (for\n        // example, because the method waits for them) their\n        // writes will be included in the fence.\n        fence.retire();\n        self.send({\n          msg: 'updated', methods: [msg.id]});\n      });\n\n      // Find the handler\n      var handler = self.server.method_handlers[msg.method];\n      if (!handler) {\n        self.send({\n          msg: 'result', id: msg.id,\n          error: new Meteor.Error(404, `Method '${msg.method}' not found`)});\n        fence.arm();\n        return;\n      }\n\n      var setUserId = function(userId) {\n        self._setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: false,\n        userId: self.userId,\n        setUserId: setUserId,\n        unblock: unblock,\n        connection: self.connectionHandle,\n        randomSeed: randomSeed\n      });\n\n      const promise = new Promise((resolve, reject) => {\n        // XXX It'd be better if we could hook into method handlers better but\n        // for now, we need to check if the ddp-rate-limiter exists since we\n        // have a weak requirement for the ddp-rate-limiter package to be added\n        // to our application.\n        if (Package['ddp-rate-limiter']) {\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n          var rateLimiterInput = {\n            userId: self.userId,\n            clientAddress: self.connectionHandle.clientAddress,\n            type: \"method\",\n            name: msg.method,\n            connectionId: self.id\n          };\n          DDPRateLimiter._increment(rateLimiterInput);\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput)\n          if (!rateLimitResult.allowed) {\n            reject(new Meteor.Error(\n              \"too-many-requests\",\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset}\n            ));\n            return;\n          }\n        }\n\n        const getCurrentMethodInvocationResult = () => {\n          const currentContext = DDP._CurrentMethodInvocation._setNewContextAndGetCurrent(\n            invocation\n          );\n\n          try {\n            let result;\n            const resultOrThenable = maybeAuditArgumentChecks(\n              handler,\n              invocation,\n              msg.params,\n              \"call to '\" + msg.method + \"'\"\n            );\n            const isThenable =\n              resultOrThenable && typeof resultOrThenable.then === 'function';\n            if (isThenable) {\n              result = Promise.await(resultOrThenable);\n            } else {\n              result = resultOrThenable;\n            }\n            return result;\n          } finally {\n            DDP._CurrentMethodInvocation._set(currentContext);\n          }\n        };\n\n        resolve(DDPServer._CurrentWriteFence.withValue(fence, getCurrentMethodInvocationResult));\n      });\n\n      function finish() {\n        fence.arm();\n        unblock();\n      }\n\n      const payload = {\n        msg: \"result\",\n        id: msg.id\n      };\n\n      promise.then(result => {\n        finish();\n        if (result !== undefined) {\n          payload.result = result;\n        }\n        self.send(payload);\n      }, (exception) => {\n        finish();\n        payload.error = wrapInternalException(\n          exception,\n          `while invoking method '${msg.method}'`\n        );\n        self.send(payload);\n      });\n    }\n  },\n\n  _eachSub: function (f) {\n    var self = this;\n    self._namedSubs.forEach(f);\n    self._universalSubs.forEach(f);\n  },\n\n  _diffCollectionViews: function (beforeCVs) {\n    var self = this;\n    DiffSequence.diffMaps(beforeCVs, self.collectionViews, {\n      both: function (collectionName, leftValue, rightValue) {\n        rightValue.diff(leftValue);\n      },\n      rightOnly: function (collectionName, rightValue) {\n        rightValue.documents.forEach(function (docView, id) {\n          self.sendAdded(collectionName, id, docView.getFields());\n        });\n      },\n      leftOnly: function (collectionName, leftValue) {\n        leftValue.documents.forEach(function (doc, id) {\n          self.sendRemoved(collectionName, id);\n        });\n      }\n    });\n  },\n\n  // Sets the current user id in all appropriate contexts and reruns\n  // all subscriptions\n  _setUserId: function(userId) {\n    var self = this;\n\n    if (userId !== null && typeof userId !== \"string\")\n      throw new Error(\"setUserId must be called on string or null, not \" +\n                      typeof userId);\n\n    // Prevent newly-created universal subscriptions from being added to our\n    // session. They will be found below when we call startUniversalSubs.\n    //\n    // (We don't have to worry about named subscriptions, because we only add\n    // them when we process a 'sub' message. We are currently processing a\n    // 'method' message, and the method did not unblock, because it is illegal\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a\n    // new named subscription).\n    self._dontStartNewUniversalSubs = true;\n\n    // Prevent current subs from updating our collectionViews and call their\n    // stop callbacks. This may yield.\n    self._eachSub(function (sub) {\n      sub._deactivate();\n    });\n\n    // All subs should now be deactivated. Stop sending messages to the client,\n    // save the state of the published collections, reset to an empty view, and\n    // update the userId.\n    self._isSending = false;\n    var beforeCVs = self.collectionViews;\n    self.collectionViews = new Map();\n    self.userId = userId;\n\n    // _setUserId is normally called from a Meteor method with\n    // DDP._CurrentMethodInvocation set. But DDP._CurrentMethodInvocation is not\n    // expected to be set inside a publish function, so we temporary unset it.\n    // Inside a publish function DDP._CurrentPublicationInvocation is set.\n    DDP._CurrentMethodInvocation.withValue(undefined, function () {\n      // Save the old named subs, and reset to having no subscriptions.\n      var oldNamedSubs = self._namedSubs;\n      self._namedSubs = new Map();\n      self._universalSubs = [];\n\n      oldNamedSubs.forEach(function (sub, subscriptionId) {\n        var newSub = sub._recreate();\n        self._namedSubs.set(subscriptionId, newSub);\n        // nb: if the handler throws or calls this.error(), it will in fact\n        // immediately send its 'nosub'. This is OK, though.\n        newSub._runHandler();\n      });\n\n      // Allow newly-created universal subs to be started on our connection in\n      // parallel with the ones we're spinning up here, and spin up universal\n      // subs.\n      self._dontStartNewUniversalSubs = false;\n      self.startUniversalSubs();\n    });\n\n    // Start sending messages again, beginning with the diff from the previous\n    // state of the world to the current state. No yields are allowed during\n    // this diff, so that other changes cannot interleave.\n    Meteor._noYieldsAllowed(function () {\n      self._isSending = true;\n      self._diffCollectionViews(beforeCVs);\n      if (!_.isEmpty(self._pendingReady)) {\n        self.sendReady(self._pendingReady);\n        self._pendingReady = [];\n      }\n    });\n  },\n\n  _startSubscription: function (handler, subId, params, name) {\n    var self = this;\n\n    var sub = new Subscription(\n      self, handler, subId, params, name);\n\n    let unblockHander = self.cachedUnblock;\n    // _startSubscription may call from a lot places\n    // so cachedUnblock might be null in somecases\n    // assign the cachedUnblock\n    sub.unblock = unblockHander || (() => {});\n\n    if (subId)\n      self._namedSubs.set(subId, sub);\n    else\n      self._universalSubs.push(sub);\n\n    sub._runHandler();\n  },\n\n  // Tear down specified subscription\n  _stopSubscription: function (subId, error) {\n    var self = this;\n\n    var subName = null;\n    if (subId) {\n      var maybeSub = self._namedSubs.get(subId);\n      if (maybeSub) {\n        subName = maybeSub._name;\n        maybeSub._removeAllDocuments();\n        maybeSub._deactivate();\n        self._namedSubs.delete(subId);\n      }\n    }\n\n    var response = {msg: 'nosub', id: subId};\n\n    if (error) {\n      response.error = wrapInternalException(\n        error,\n        subName ? (\"from sub \" + subName + \" id \" + subId)\n          : (\"from sub id \" + subId));\n    }\n\n    self.send(response);\n  },\n\n  // Tear down all subscriptions. Note that this does NOT send removed or nosub\n  // messages, since we assume the client is gone.\n  _deactivateAllSubscriptions: function () {\n    var self = this;\n\n    self._namedSubs.forEach(function (sub, id) {\n      sub._deactivate();\n    });\n    self._namedSubs = new Map();\n\n    self._universalSubs.forEach(function (sub) {\n      sub._deactivate();\n    });\n    self._universalSubs = [];\n  },\n\n  // Determine the remote client's IP address, based on the\n  // HTTP_FORWARDED_COUNT environment variable representing how many\n  // proxies the server is behind.\n  _clientAddress: function () {\n    var self = this;\n\n    // For the reported client address for a connection to be correct,\n    // the developer must set the HTTP_FORWARDED_COUNT environment\n    // variable to an integer representing the number of hops they\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\n    // server is behind one proxy.\n    //\n    // This could be computed once at startup instead of every time.\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\n\n    if (httpForwardedCount === 0)\n      return self.socket.remoteAddress;\n\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\n    if (! _.isString(forwardedFor))\n      return null;\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);\n\n    // Typically the first value in the `x-forwarded-for` header is\n    // the original IP address of the client connecting to the first\n    // proxy.  However, the end user can easily spoof the header, in\n    // which case the first value(s) will be the fake IP address from\n    // the user pretending to be a proxy reporting the original IP\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the\n    // end of the list, we ensure that we get the IP address being\n    // reported by *our* first proxy.\n\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length)\n      return null;\n\n    return forwardedFor[forwardedFor.length - httpForwardedCount];\n  }\n});\n\n/******************************************************************************/\n/* Subscription                                                               */\n/******************************************************************************/\n\n// Ctor for a sub handle: the input to each publish function\n\n// Instance name is this because it's usually referred to as this inside a\n// publish\n/**\n * @summary The server's side of a subscription\n * @class Subscription\n * @instanceName this\n * @showInstanceName true\n */\nvar Subscription = function (\n    session, handler, subscriptionId, params, name) {\n  var self = this;\n  self._session = session; // type is Session\n\n  /**\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server\n   * @name  connection\n   * @memberOf Subscription\n   * @instance\n   */\n  self.connection = session.connectionHandle; // public API object\n\n  self._handler = handler;\n\n  // My subscription ID (generated by client, undefined for universal subs).\n  self._subscriptionId = subscriptionId;\n  // Undefined for universal subs\n  self._name = name;\n\n  self._params = params || [];\n\n  // Only named subscriptions have IDs, but we need some sort of string\n  // internally to keep track of all subscriptions inside\n  // SessionDocumentViews. We use this subscriptionHandle for that.\n  if (self._subscriptionId) {\n    self._subscriptionHandle = 'N' + self._subscriptionId;\n  } else {\n    self._subscriptionHandle = 'U' + Random.id();\n  }\n\n  // Has _deactivate been called?\n  self._deactivated = false;\n\n  // Stop callbacks to g/c this sub.  called w/ zero arguments.\n  self._stopCallbacks = [];\n\n  // The set of (collection, documentid) that this subscription has\n  // an opinion about.\n  self._documents = new Map();\n\n  // Remember if we are ready.\n  self._ready = false;\n\n  // Part of the public API: the user of this sub.\n\n  /**\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\n   * @locus Server\n   * @memberOf Subscription\n   * @name  userId\n   * @instance\n   */\n  self.userId = session.userId;\n\n  // For now, the id filter is going to default to\n  // the to/from DDP methods on MongoID, to\n  // specifically deal with mongo/minimongo ObjectIds.\n\n  // Later, you will be able to make this be \"raw\"\n  // if you want to publish a collection that you know\n  // just has strings for keys and no funny business, to\n  // a DDP consumer that isn't minimongo.\n\n  self._idFilter = {\n    idStringify: MongoID.idStringify,\n    idParse: MongoID.idParse\n  };\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"livedata\", \"subscriptions\", 1);\n};\n\nObject.assign(Subscription.prototype, {\n  _runHandler: function() {\n    // XXX should we unblock() here? Either before running the publish\n    // function, or before running _publishCursor.\n    //\n    // Right now, each publish function blocks all future publishes and\n    // methods waiting on data from Mongo (or whatever else the function\n    // blocks on). This probably slows page load in common cases.\n\n    if (!this.unblock) {\n      this.unblock = () => {};\n    }\n\n    const self = this;\n    let resultOrThenable = null;\n    try {\n      resultOrThenable = DDP._CurrentPublicationInvocation.withValue(self, () =>\n        maybeAuditArgumentChecks(\n          self._handler,\n          self,\n          EJSON.clone(self._params),\n          // It's OK that this would look weird for universal subscriptions,\n          // because they have no arguments so there can never be an\n          // audit-argument-checks failure.\n          \"publisher '\" + self._name + \"'\"\n        )\n      );\n    } catch (e) {\n      self.error(e);\n      return;\n    }\n\n    // Did the handler call this.error or this.stop?\n    if (self._isDeactivated()) return;\n\n    // Both conventional and async publish handler functions are supported.\n    // If an object is returned with a then() function, it is either a promise\n    // or thenable and will be resolved asynchronously.\n    const isThenable =\n      resultOrThenable && typeof resultOrThenable.then === 'function';\n    if (isThenable) {\n      Promise.resolve(resultOrThenable).then(\n        (...args) => self._publishHandlerResult.bind(self)(...args),\n        e => self.error(e)\n      );\n    } else {\n      self._publishHandlerResult(resultOrThenable);\n    }\n  },\n\n  _publishHandlerResult: function (res) {\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke\n    // this.added/changed/ready/etc, the user can just return a collection\n    // cursor or array of cursors from the publish function; we call their\n    // _publishCursor method which starts observing the cursor and publishes the\n    // results. Note that _publishCursor does NOT call ready().\n    //\n    // XXX This uses an undocumented interface which only the Mongo cursor\n    // interface publishes. Should we make this interface public and encourage\n    // users to implement it themselves? Arguably, it's unnecessary; users can\n    // already write their own functions like\n    //   var publishMyReactiveThingy = function (name, handler) {\n    //     Meteor.publish(name, function () {\n    //       var reactiveThingy = handler();\n    //       reactiveThingy.publishMe();\n    //     });\n    //   };\n\n    var self = this;\n    var isCursor = function (c) {\n      return c && c._publishCursor;\n    };\n    if (isCursor(res)) {\n      try {\n        res._publishCursor(self);\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      // _publishCursor only returns after the initial added callbacks have run.\n      // mark subscription as ready.\n      self.ready();\n    } else if (_.isArray(res)) {\n      // Check all the elements are cursors\n      if (! _.all(res, isCursor)) {\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));\n        return;\n      }\n      // Find duplicate collection names\n      // XXX we should support overlapping cursors, but that would require the\n      // merge box to allow overlap within a subscription\n      var collectionNames = {};\n      for (var i = 0; i < res.length; ++i) {\n        var collectionName = res[i]._getCollectionName();\n        if (_.has(collectionNames, collectionName)) {\n          self.error(new Error(\n            \"Publish function returned multiple cursors for collection \" +\n              collectionName));\n          return;\n        }\n        collectionNames[collectionName] = true;\n      };\n\n      try {\n        _.each(res, function (cur) {\n          cur._publishCursor(self);\n        });\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      self.ready();\n    } else if (res) {\n      // Truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      self.error(new Error(\"Publish function can only return a Cursor or \"\n                           + \"an array of Cursors\"));\n    }\n  },\n\n  // This calls all stop callbacks and prevents the handler from updating any\n  // SessionCollectionViews further. It's used when the user unsubscribes or\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\n  // removed messages for the published objects; if that is necessary, call\n  // _removeAllDocuments first.\n  _deactivate: function() {\n    var self = this;\n    if (self._deactivated)\n      return;\n    self._deactivated = true;\n    self._callStopCallbacks();\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"livedata\", \"subscriptions\", -1);\n  },\n\n  _callStopCallbacks: function () {\n    var self = this;\n    // Tell listeners, so they can clean up\n    var callbacks = self._stopCallbacks;\n    self._stopCallbacks = [];\n    _.each(callbacks, function (callback) {\n      callback();\n    });\n  },\n\n  // Send remove messages for every document.\n  _removeAllDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._documents.forEach(function (collectionDocs, collectionName) {\n        collectionDocs.forEach(function (strId) {\n          self.removed(collectionName, self._idFilter.idParse(strId));\n        });\n      });\n    });\n  },\n\n  // Returns a new Subscription for the same session with the same\n  // initial creation parameters. This isn't a clone: it doesn't have\n  // the same _documents cache, stopped state or callbacks; may have a\n  // different _subscriptionHandle, and gets its userId from the\n  // session, not from this object.\n  _recreate: function () {\n    var self = this;\n    return new Subscription(\n      self._session, self._handler, self._subscriptionId, self._params,\n      self._name);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server\n   * @param {Error} error The error to pass to the client.\n   * @instance\n   * @memberOf Subscription\n   */\n  error: function (error) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId, error);\n  },\n\n  // Note that while our DDP client will notice that you've called stop() on the\n  // server (and clean up its _subscriptions table) we don't actually provide a\n  // mechanism for an app to notice this (the subscribe onError callback only\n  // triggers if there is an error).\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server\n   * @instance\n   * @memberOf Subscription\n   */\n  stop: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {Function} func The callback function\n   */\n  onStop: function (callback) {\n    var self = this;\n    callback = Meteor.bindEnvironment(callback, 'onStop callback', self);\n    if (self._isDeactivated())\n      callback();\n    else\n      self._stopCallbacks.push(callback);\n  },\n\n  // This returns true if the sub has been deactivated, *OR* if the session was\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\n  // happened yet.\n  _isDeactivated: function () {\n    var self = this;\n    return self._deactivated || self._session.inQueue === null;\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the new document.\n   * @param {String} id The new document's ID.\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\n   */\n  added (collectionName, id, fields) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      let ids = this._documents.get(collectionName);\n      if (ids == null) {\n        ids = new Set();\n        this._documents.set(collectionName, ids);\n      }\n      ids.add(id);\n    }\n\n    this._session.added(this._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the changed document.\n   * @param {String} id The changed document's ID.\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */\n  changed (collectionName, id, fields) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n    this._session.changed(this._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that the document has been removed from.\n   * @param {String} id The ID of the document that has been removed.\n   */\n  removed (collectionName, id) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      // We don't bother to delete sets of things in a collection if the\n      // collection is empty.  It could break _removeAllDocuments.\n      this._documents.get(collectionName).delete(id);\n    }\n\n    this._session.removed(this._subscriptionHandle, collectionName, id);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   */\n  ready: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    if (!self._subscriptionId)\n      return;  // Unnecessary but ignored for universal sub\n    if (!self._ready) {\n      self._session.sendReady([self._subscriptionId]);\n      self._ready = true;\n    }\n  }\n});\n\n/******************************************************************************/\n/* Server                                                                     */\n/******************************************************************************/\n\nServer = function (options = {}) {\n  var self = this;\n\n  // The default heartbeat interval is 30 seconds on the server and 35\n  // seconds on the client.  Since the client doesn't need to send a\n  // ping as long as it is receiving pings, this means that pings\n  // normally go from the server to the client.\n  //\n  // Note: Troposphere depends on the ability to mutate\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n  self.options = {\n    heartbeatInterval: 15000,\n    heartbeatTimeout: 15000,\n    // For testing, allow responding to pings to be disabled.\n    respondToPings: true,\n    defaultPublicationStrategy: publicationStrategies.SERVER_MERGE,\n    ...options,\n  };\n\n  // Map of callbacks to call when a new connection comes in to the\n  // server and completes DDP version negotiation. Use an object instead\n  // of an array so we can safely remove one from the list while\n  // iterating over it.\n  self.onConnectionHook = new Hook({\n    debugPrintExceptions: \"onConnection callback\"\n  });\n\n  // Map of callbacks to call when a new message comes in.\n  self.onMessageHook = new Hook({\n    debugPrintExceptions: \"onMessage callback\"\n  });\n\n  self.publish_handlers = {};\n  self.universal_publish_handlers = [];\n\n  self.method_handlers = {};\n\n  self._publicationStrategies = {};\n\n  self.sessions = new Map(); // map from id to session\n\n  self.stream_server = new StreamServer;\n\n  self.stream_server.register(function (socket) {\n    // socket implements the SockJSConnection interface\n    socket._meteorSession = null;\n\n    var sendError = function (reason, offendingMessage) {\n      var msg = {msg: 'error', reason: reason};\n      if (offendingMessage)\n        msg.offendingMessage = offendingMessage;\n      socket.send(DDPCommon.stringifyDDP(msg));\n    };\n\n    socket.on('data', function (raw_msg) {\n      if (Meteor._printReceivedDDP) {\n        Meteor._debug(\"Received DDP\", raw_msg);\n      }\n      try {\n        try {\n          var msg = DDPCommon.parseDDP(raw_msg);\n        } catch (err) {\n          sendError('Parse error');\n          return;\n        }\n        if (msg === null || !msg.msg) {\n          sendError('Bad request', msg);\n          return;\n        }\n\n        if (msg.msg === 'connect') {\n          if (socket._meteorSession) {\n            sendError(\"Already connected\", msg);\n            return;\n          }\n          Fiber(function () {\n            self._handleConnect(socket, msg);\n          }).run();\n          return;\n        }\n\n        if (!socket._meteorSession) {\n          sendError('Must connect first', msg);\n          return;\n        }\n        socket._meteorSession.processMessage(msg);\n      } catch (e) {\n        // XXX print stack nicely\n        Meteor._debug(\"Internal exception while processing message\", msg, e);\n      }\n    });\n\n    socket.on('close', function () {\n      if (socket._meteorSession) {\n        Fiber(function () {\n          socket._meteorSession.close();\n        }).run();\n      }\n    });\n  });\n};\n\nObject.assign(Server.prototype, {\n\n  /**\n   * @summary Register a callback to be called when a new DDP connection is made to the server.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP connection is established.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onConnection: function (fn) {\n    var self = this;\n    return self.onConnectionHook.register(fn);\n  },\n\n  /**\n   * @summary Set publication strategy for the given collection. Publications strategies are available from `DDPServer.publicationStrategies`. You call this method from `Meteor.server`, like `Meteor.server.setPublicationStrategy()`\n   * @locus Server\n   * @alias setPublicationStrategy\n   * @param collectionName {String}\n   * @param strategy {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   */\n  setPublicationStrategy(collectionName, strategy) {\n    if (!Object.values(publicationStrategies).includes(strategy)) {\n      throw new Error(`Invalid merge strategy: ${strategy} \n        for collection ${collectionName}`);\n    }\n    this._publicationStrategies[collectionName] = strategy;\n  },\n\n  /**\n   * @summary Gets the publication strategy for the requested collection. You call this method from `Meteor.server`, like `Meteor.server.getPublicationStrategy()`\n   * @locus Server\n   * @alias getPublicationStrategy\n   * @param collectionName {String}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   * @return {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   */\n  getPublicationStrategy(collectionName) {\n    return this._publicationStrategies[collectionName]\n      || this.options.defaultPublicationStrategy;\n  },\n\n  /**\n   * @summary Register a callback to be called when a new DDP message is received.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP message is received.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onMessage: function (fn) {\n    var self = this;\n    return self.onMessageHook.register(fn);\n  },\n\n  _handleConnect: function (socket, msg) {\n    var self = this;\n\n    // The connect message must specify a version and an array of supported\n    // versions, and it must claim to support what it is proposing.\n    if (!(typeof (msg.version) === 'string' &&\n          _.isArray(msg.support) &&\n          _.all(msg.support, _.isString) &&\n          _.contains(msg.support, msg.version))) {\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed',\n                                version: DDPCommon.SUPPORTED_DDP_VERSIONS[0]}));\n      socket.close();\n      return;\n    }\n\n    // In the future, handle session resumption: something like:\n    //  socket._meteorSession = self.sessions[msg.session]\n    var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);\n\n    if (msg.version !== version) {\n      // The best version to use (according to the client's stated preferences)\n      // is not the one the client is trying to use. Inform them about the best\n      // version to use.\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed', version: version}));\n      socket.close();\n      return;\n    }\n\n    // Yay, version matches! Create a new session.\n    // Note: Troposphere depends on the ability to mutate\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n    socket._meteorSession = new Session(self, version, socket, self.options);\n    self.sessions.set(socket._meteorSession.id, socket._meteorSession);\n    self.onConnectionHook.each(function (callback) {\n      if (socket._meteorSession)\n        callback(socket._meteorSession.connectionHandle);\n      return true;\n    });\n  },\n  /**\n   * Register a publish handler function.\n   *\n   * @param name {String} identifier for query\n   * @param handler {Function} publish handler\n   * @param options {Object}\n   *\n   * Server will call handler function on each new subscription,\n   * either when receiving DDP sub message for a named subscription, or on\n   * DDP connect for a universal subscription.\n   *\n   * If name is null, this will be a subscription that is\n   * automatically established and permanently on for all connected\n   * client, instead of a subscription that can be turned on and off\n   * with subscribe().\n   *\n   * options to contain:\n   *  - (mostly internal) is_auto: true if generated automatically\n   *    from an autopublish hook. this is for cosmetic purposes only\n   *    (it lets us determine whether to print a warning suggesting\n   *    that you turn off autopublish).\n   */\n\n  /**\n   * @summary Publish a record set.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @locus Server\n   * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */\n  publish: function (name, handler, options) {\n    var self = this;\n\n    if (! _.isObject(name)) {\n      options = options || {};\n\n      if (name && name in self.publish_handlers) {\n        Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\n        return;\n      }\n\n      if (Package.autopublish && !options.is_auto) {\n        // They have autopublish on, yet they're trying to manually\n        // pick stuff to publish. They probably should turn off\n        // autopublish. (This check isn't perfect -- if you create a\n        // publish before you turn on autopublish, it won't catch\n        // it, but this will definitely handle the simple case where\n        // you've added the autopublish package to your app, and are\n        // calling publish from your app code).\n        if (!self.warned_about_autopublish) {\n          self.warned_about_autopublish = true;\n          Meteor._debug(\n    \"** You've set up some data subscriptions with Meteor.publish(), but\\n\" +\n    \"** you still have autopublish turned on. Because autopublish is still\\n\" +\n    \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" +\n    \"** will still be sent to all clients.\\n\" +\n    \"**\\n\" +\n    \"** Turn off autopublish by removing the autopublish package:\\n\" +\n    \"**\\n\" +\n    \"**   $ meteor remove autopublish\\n\" +\n    \"**\\n\" +\n    \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" +\n    \"** for each collection that you want clients to see.\\n\");\n        }\n      }\n\n      if (name)\n        self.publish_handlers[name] = handler;\n      else {\n        self.universal_publish_handlers.push(handler);\n        // Spin up the new publisher on any existing session too. Run each\n        // session's subscription in a new Fiber, so that there's no change for\n        // self.sessions to change while we're running this loop.\n        self.sessions.forEach(function (session) {\n          if (!session._dontStartNewUniversalSubs) {\n            Fiber(function() {\n              session._startSubscription(handler);\n            }).run();\n          }\n        });\n      }\n    }\n    else{\n      _.each(name, function(value, key) {\n        self.publish(key, value, {});\n      });\n    }\n  },\n\n  _removeSession: function (session) {\n    var self = this;\n    self.sessions.delete(session.id);\n  },\n\n  /**\n   * @summary Defines functions that can be invoked over the network by clients.\n   * @locus Anywhere\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  methods: function (methods) {\n    var self = this;\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self.method_handlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self.method_handlers[name] = func;\n    });\n  },\n\n  call: function (name, ...args) {\n    if (args.length && typeof args[args.length - 1] === \"function\") {\n      // If it's a function, the last argument is the result callback, not\n      // a parameter to the remote method.\n      var callback = args.pop();\n    }\n\n    return this.apply(name, args, callback);\n  },\n\n  // A version of the call method that always returns a Promise.\n  callAsync: function (name, ...args) {\n    return this.applyAsync(name, args);\n  },\n\n  apply: function (name, args, options, callback) {\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (! callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else {\n      options = options || {};\n    }\n\n    const promise = this.applyAsync(name, args, options);\n\n    // Return the result in whichever way the caller asked for it. Note that we\n    // do NOT block on the write fence in an analogous way to how the client\n    // blocks on the relevant data being visible, so you are NOT guaranteed that\n    // cursor observe callbacks have fired when your callback is invoked. (We\n    // can change this if there's a real use case).\n    if (callback) {\n      promise.then(\n        result => callback(undefined, result),\n        exception => callback(exception)\n      );\n    } else {\n      return promise.await();\n    }\n  },\n\n  // @param options {Optional Object}\n  applyAsync: function (name, args, options) {\n    // Run the handler\n    var handler = this.method_handlers[name];\n    if (! handler) {\n      return Promise.reject(\n        new Meteor.Error(404, `Method '${name}' not found`)\n      );\n    }\n\n    // If this is a method call from within another method or publish function,\n    // get the user state from the outer method or publish function, otherwise\n    // don't allow setUserId to be called\n    var userId = null;\n    var setUserId = function() {\n      throw new Error(\"Can't call setUserId on a server initiated method call\");\n    };\n    var connection = null;\n    var currentMethodInvocation = DDP._CurrentMethodInvocation.get();\n    var currentPublicationInvocation = DDP._CurrentPublicationInvocation.get();\n    var randomSeed = null;\n    if (currentMethodInvocation) {\n      userId = currentMethodInvocation.userId;\n      setUserId = function(userId) {\n        currentMethodInvocation.setUserId(userId);\n      };\n      connection = currentMethodInvocation.connection;\n      randomSeed = DDPCommon.makeRpcSeed(currentMethodInvocation, name);\n    } else if (currentPublicationInvocation) {\n      userId = currentPublicationInvocation.userId;\n      setUserId = function(userId) {\n        currentPublicationInvocation._session._setUserId(userId);\n      };\n      connection = currentPublicationInvocation.connection;\n    }\n\n    var invocation = new DDPCommon.MethodInvocation({\n      isSimulation: false,\n      userId,\n      setUserId,\n      connection,\n      randomSeed\n    });\n\n    return new Promise(resolve => resolve(\n      DDP._CurrentMethodInvocation.withValue(\n        invocation,\n        () => maybeAuditArgumentChecks(\n          handler, invocation, EJSON.clone(args),\n          \"internal call to '\" + name + \"'\"\n        )\n      )\n    )).then(EJSON.clone);\n  },\n\n  _urlForSession: function (sessionId) {\n    var self = this;\n    var session = self.sessions.get(sessionId);\n    if (session)\n      return session._socketUrl;\n    else\n      return null;\n  }\n});\n\nvar calculateVersion = function (clientSupportedVersions,\n                                 serverSupportedVersions) {\n  var correctVersion = _.find(clientSupportedVersions, function (version) {\n    return _.contains(serverSupportedVersions, version);\n  });\n  if (!correctVersion) {\n    correctVersion = serverSupportedVersions[0];\n  }\n  return correctVersion;\n};\n\nDDPServer._calculateVersion = calculateVersion;\n\n\n// \"blind\" exceptions other than those that were deliberately thrown to signal\n// errors to the client\nvar wrapInternalException = function (exception, context) {\n  if (!exception) return exception;\n\n  // To allow packages to throw errors intended for the client but not have to\n  // depend on the Meteor.Error class, `isClientSafe` can be set to true on any\n  // error before it is thrown.\n  if (exception.isClientSafe) {\n    if (!(exception instanceof Meteor.Error)) {\n      const originalMessage = exception.message;\n      exception = new Meteor.Error(exception.error, exception.reason, exception.details);\n      exception.message = originalMessage;\n    }\n    return exception;\n  }\n\n  // Tests can set the '_expectedByTest' flag on an exception so it won't go to\n  // the server log.\n  if (!exception._expectedByTest) {\n    Meteor._debug(\"Exception \" + context, exception.stack);\n    if (exception.sanitizedError) {\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError);\n      Meteor._debug();\n    }\n  }\n\n  // Did the error contain more details that could have been useful if caught in\n  // server code (or if thrown from non-client-originated code), but also\n  // provided a \"sanitized\" version with more context than 500 Internal server\n  // error? Use that.\n  if (exception.sanitizedError) {\n    if (exception.sanitizedError.isClientSafe)\n      return exception.sanitizedError;\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" +\n                  \"does not have isClientSafe property set; ignoring\");\n  }\n\n  return new Meteor.Error(500, \"Internal server error\");\n};\n\n\n// Audit argument checks, if the audit-argument-checks package exists (it is a\n// weak dependency of this package).\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\n  args = args || [];\n  if (Package['audit-argument-checks']) {\n    return Match._failIfArgumentsAreNotAllChecked(\n      f, context, args, description);\n  }\n  return f.apply(context, args);\n};\n"],"mappings":"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"},"sourceType":"module","externalDependencies":{},"hash":"ab872b9e9f5135163ce7b4b5d4436b07d5f896c8"}
